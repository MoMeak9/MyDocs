---
title: LeetCode 简单题（1）
date: 2021-10-26
author: MoMeaks
sidebar: 'auto'
categories:
- 算法
tags:
- Python
- javascript
---

:::tip
[来源剑指offer](https://leetcode-cn.com/problem-list/xb9nqhhg/)
:::

### 斐波那契 I

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

#### Solution

**方法一、动态规划**

```python
class Solution:
    def fib(self, n: int) -> int:
        MOD = 10 ** 9 + 7
        if n < 2:
            return n
        p, q, r = 0, 0, 1
        for i in range(2, n + 1):
            p = q
            q = r
            r = (p + q) % MOD
        return r
```

```javascript
var fib = function(n) {
    const MOD = 1000000007;
    if (n < 2) {
        return n;
    }
    let p = 0, q = 0, r = 1;
    for (let i = 2; i <= n; ++i) {
        p = q; 
        q = r; 
        r = (p + q) % MOD;
    }
    return r;
}
```

### 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

> 读不懂题目不是我的错
> 
> 输入：
> ["CQueue","appendTail","deleteHead","deleteHead"] 
> 
> 这一行表示每一行代码的操作
>
> [[],[3],[],[]]
> 
> 这个表示每一行代码操作所需要的参数
>
> 举例：
> CQueue 表示新建一个CQueue对象，对应的所需参数为[]，即此操作不需要参数。
> 
> appendTail 表示执行一个appendTail()操作，对应要被操作的元素为3。
> 
> deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。
> 
> deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。


示例 1：
```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

示例 2：
```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

提示：

1 <= values <= 10000
最多会对appendTail、deleteHead 进行10000次调用

#### Solution
**双栈**

```javascript
var CQueue = function() {
    this.stackA = [];
    this.stackB = [];
};

CQueue.prototype.appendTail = function(value) {
    this.stackA.push(value);
};

CQueue.prototype.deleteHead = function() {
    if(this.stackB.length){
        return this.stackB.pop();
    }else{
        while(this.stackA.length){
            this.stackB.push(this.stackA.pop());
        }
        if(!this.stackB.length){
            return -1;
        }else{
            return this.stackB.pop();
        }
    }
};
```

```py
class CQueue:

    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def appendTail(self, value: int) -> None:
        # 1 -> 2
        while self.stack1:
            self.stack2.append(self.stack1.pop())
        # add value
        self.stack1.append(value)
        # 1 <- 2
        while self.stack2:
            self.stack1.append(self.stack2.pop())
        return self.stack1

    def deleteHead(self) -> int:
        if not self.stack1: return -1
        return self.stack1.pop()
```
