# CS357 è½¯ä»¶éªŒè¯ software 

## L2 **Design by Contract** ï¼ˆDBCï¼‰

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220200309056.png" alt="image-20211220200309056" style="zoom: 67%;" />

å¥‘çº¦å¼è®¾è®¡/å¥‘çº¦å¼ç¼–ç ï¼ˆDesign by Contract(DbC)/Programming by Contractï¼Œä»¥ä¸‹ç®€ç§° DbC ï¼‰æ˜¯ä¸€ç§è®¾è®¡è®¡ç®—æœºè½¯ä»¶çš„æ–¹æ³•ã€‚è¿™ç§æ–¹æ³•æè¿°äº†ï¼Œè½¯ä»¶è®¾è®¡è€…åº”è¯¥ä¸ºè½¯ä»¶ç»„ä»¶å®šä¹‰æ­£å¼çš„ã€å‡†ç¡®çš„ã€å¯éªŒè¯çš„æ¥å£è§„èŒƒã€‚

### Key concept

**The supplier: ** Wrote the class code; documents it, maintains it; knows about the class  implementation; publishes the class interface.

**The client:**  Uses the class in their own code; reads the documentation (presumably);  knows about the class interface; knows nothing about the implementation.

### Main principles

- Every public method has a precondition and a postcondition.
- The precondition expresses the constraints under which the method will  function properly 
- The postcondition expresses what will happen when a method executes  properly

### çŸ¥è¯†ç‚¹ï¼š

**Non-redundancy principle éå†—ä½™åŸç†:** The body of a method shall not check to see if the  precondition is true.

**Precondition Availability Rule å¯ç”¨æ€§è§„åˆ™å‰æ**: Every feature appearing in the precondition of  a routine must be available to every client to which the routine is available

**Inheritance:**

Assume A is a superclass of B; then  

- B inherits all the (non-private) methods and instance variables from A.  

- B might add more of these (extending the class), or change the  implementation of some methods (overriding the method)

- Therefore, a B-object must be able to do anything that an A-object can do;  i.e. it must be capable of behaving exactly like an A-object

## L3&4 Logic for Program  Specification

###  :star:Natural Deduction Rules è‡ªç„¶æ¼”ç»è§„åˆ™(è¯æ˜)

<img src="images/image-20211205213424950.png" alt="image-20211205213424950" style="zoom: 67%;" />

å¦‚æœA, Bæ˜¯æ­£ç¡®çš„ï¼Œåˆ™é€šè¿‡è§„åˆ™exampleOneï¼Œåˆ¤æ–­Xæ˜¯çœŸçš„

<img src="images/image-20211205213809572.png" alt="image-20211205213809572" style="zoom:67%;" />

å¦‚æœæˆ‘ä»¬å·²ç»è¯æ˜Aä¸ºçœŸï¼Œå¦‚æœæˆ‘ä»¬å·²ç»è¯æ˜å½“æˆ‘ä»¬å‡è®¾Bï¼Œé‚£ä¹ˆCä¹Ÿä¸ºçœŸï¼Œé‚£ä¹ˆè¿™ä¸ªå«åšexampleTwoçš„è§„åˆ™ï¼Œå…è®¸æˆ‘ä»¬æ¨æ–­Xä¸ºçœŸ

åœ¨è¿™é‡Œï¼ŒBæ˜¯ä¸€ä¸ªå±€éƒ¨çš„æˆ–ä¸´æ—¶çš„å‡è®¾ï¼Œå½“æˆ‘ä»¬åº”ç”¨è§„åˆ™æ—¶ï¼Œå®ƒè¢«è§£é™¤ã€‚

#### ä»‹å…¥ä¸æ¶ˆå»è§„åˆ™

<img src="images/image-20211205214438414.png" alt="image-20211205214438414" style="zoom: 50%;" />

#### Assumptions in natural deduction

è‡ªç„¶æ¼”ç»ä¸­çš„å‡è®¾è¯æ˜æ„é€ ä¸­æœ€é‡è¦çš„æ–¹é¢ä¹‹ä¸€æ˜¯**è·Ÿè¸ªå‡è®¾**ã€‚åœ¨è¯æ˜è¿‡ç¨‹ä¸­ï¼Œä¸ºäº†å¤„ç†ç‰¹å®šçš„æƒ…å†µï¼Œæˆ‘ä»¬åœ¨æŸäº›é˜¶æ®µè¿›è¡Œå‡è®¾â€”â€”å‡è®¾å¯ä»¥ä½¿è¯æ˜æ¨¡å—åŒ–ã€‚

æ‰€æœ‰å‡è®¾åº”åœ¨è¯æ˜ç»“æŸæ—¶è§£é™¤:å› ä¸ºåªæœ‰ä¸€äº›è§„åˆ™å…è®¸ä½ è¿›è¡Œå‡è®¾ï¼Œæ‰€ä»¥ä½ åº”è¯¥åªåœ¨ä½ å†³å®šä½¿ç”¨è¿™äº›è§„åˆ™ä¹‹ä¸€ä¹‹åæ‰å¼•å…¥å‡è®¾

![image-20211206205753767](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206205753767.png)





## L5 First Order Logic

#### :star:Predicate logic è°“è¯é€»è¾‘

è°“è¯é€»è¾‘æ˜¯è®¨è®ºäº‹ç‰©å’Œäº‹ç‰©ä¹‹é—´å…³ç³»çš„é€»è¾‘çš„äº‹æƒ…ã€‚

Predicate logic is the logic for discussing things and relationships between things.

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206210821371.png" alt="image-20211206210821371" style="zoom:67%;" />

æœ‰ä¸€é˜¶é€»è¾‘ï¼ŒäºŒé˜¶é€»è¾‘ï¼Œå¤šç±»é€»è¾‘æˆ–æ— ç©·é€»è¾‘ç­‰ç­‰ã€‚

There is first-order logic, second-order logic, multi-class logic or infinite logic, and so on.

####  :star:Propositional logic å‘½é¢˜é€»è¾‘

åœ¨é€»è¾‘å’Œæ•°å­¦é‡Œï¼Œå‘½é¢˜æ¼”ç®—ï¼ˆæˆ–ç§°å¥å­æ¼”ç®—ï¼‰æ˜¯ä¸€ä¸ªå½¢å¼ç³»ç»Ÿï¼Œæœ‰ç€å¯ä»¥ç”±ä»¥é€»è¾‘è¿ç®—ç¬¦ç»“åˆåŸå­å‘½é¢˜æ¥æ„æˆä»£è¡¨â€œå‘½é¢˜â€çš„å…¬å¼ï¼Œä»¥åŠå…è®¸æŸäº›å…¬å¼å»ºæ„æˆâ€œå®šç†â€çš„ä¸€å¥—å½¢å¼â€œè¯æ˜è§„åˆ™â€ã€‚

In logic and mathematics, propositional calculus (or sentence calculus) is a formal system with formulas representing "propositions" that can be formed by combining atomic propositions with logical operators, and a set of formal "proof rules" that allow certain formulas to form "theorems".

**äºŒè€…å…³ç³»ï¼š** **å‘½é¢˜é€»è¾‘å¯ä»¥çœ‹ä½œè°“è¯é€»è¾‘çš„ä¸€ä¸ªå­é›†**ã€‚Propositional logic can be regarded as a subset of predicate logic

**æ˜¯å°†å‘½é¢˜é€»è¾‘è¡¨è¾¾ä¸å‡ºæ¥çš„é€»è¾‘ç»§ç»­ç»†åŒ–**ï¼Œæ¯”å¦‚Aï¼ˆx,yï¼‰è¡¨ç¤ºxå–œæ¬¢yï¼Œåˆ™â€œå°æ˜å–œæ¬¢æ•°å­¦â€å¯ä»¥è¡¨ç¤ºä¸ºAï¼ˆå°æ˜ï¼Œæ•°å­¦ï¼‰

Is to further refine the logic that cannot be expressed by propositional logic, for example, A (x,y) means x likes Y, then "Xiaoming likes math" can be expressed as A (Xiaoming, math).

### å¸¸ç”¨é€»è¾‘

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206211246871.png" alt="image-20211206211246871" style="zoom:50%;" />

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206211257684.png" alt="image-20211206211257684" style="zoom:50%;" />

## L6 :star:Natural Deduction Proofs (è‡ªç„¶æ¼”ç»è¯æ˜

**Introductionï¼š**If you have a goal of the form ğ‘“ğ‘œğ‘Ÿğ‘ğ‘™ğ‘™ ğ‘¥:ğ·, ğ‘ƒ you just need to  do intro to introduce a new variable ğ‘¥: ğ· into the context.

**Eliminationï¼š**If you have a hypothesis H of the form ğ‘“ğ‘œğ‘Ÿğ‘ğ‘™ğ‘™ ğ‘¥: ğ·,ğ‘ƒ, then pick  some current variable of type ğ·, say ğ‘£, and just use ğ‘’ğ‘™ğ‘–ğ‘š (ğ» ğ‘£)æ¶ˆå»

### Example

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206214432688.png" alt="image-20211206214432688" style="zoom:50%;" />

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206214658165.png" alt="image-20211206214658165" style="zoom: 50%;" />

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206214716387.png" alt="image-20211206214716387" style="zoom: 50%;" />

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206214729407.png" alt="image-20211206214729407" style="zoom: 50%;" />

### PraseTree

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211212182854888.png" alt="image-20211212182854888" style="zoom: 10%;" />

## L8&9  :star: Formal Proof in Logic & CNF åˆå–èŒƒå¼

### :star:Models

**Validity and satisfiability**

A formula ğœ™ in propositional logic is

- **satisfiable** if it is true in some model **å¯æ»¡è¶³çš„**

  <img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220210802410.png" alt="image-20211220210802410" style="zoom: 67%;" />

- **valid** if it is true in every model (it is a tautology) **æœ‰æ•ˆçš„**

  <img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220210815335.png" alt="image-20211220210815335" style="zoom:67%;" />

- **unsatisfiable** if it is false in every model **ä¸å¯æ»¡è¶³çš„**

  ![image-20211220210851646](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220210851646.png)

ç›¸åæ€§ï¼š

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220211009350.png" alt="image-20211220211009350" style="zoom:67%;" />

### :star:soundness åˆç†æ€§

![image-20211220211232195](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220211232195.png)

### :star:completeness å®Œæ•´æ€§

![image-20211220211303807](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220211303807.png)

### :star:Conjunctive Normal Form (CNF) Translation

å…¬å¼å†…ï¼Œå­å¼å†…åªèƒ½ä¸ºæˆ–\/ï¼ˆå¹¶é›†ï¼‰ï¼Œå­å¼ä¸å­å¼ä¹‹é—´ä¸ºä¸/\ï¼ˆäº¤é›†ï¼‰ï¼Œå­å¼å¯ä»¥æ˜¯å•ä¸ªå­—æ¯ã€‚

è§„åˆ™ï¼š

1. ç®­å¤´è½¬æ¢ï¼š

å•ç®­å¤´

```
(ğ‘ âˆ§ ğ‘) -> c è‡³  Â¬ (ğ‘ âˆ§ ğ‘) âˆ¨ c)
```

```
ï¼ˆï¼ˆpâˆ¨qï¼‰â€”>rï¼‰â€”>p è‡³ (â”(pâˆ¨q)âˆ¨r)â€”>p è‡³ â”(â”(pâˆ¨q)âˆ¨r)âˆ¨p
```

åŒç®­å¤´

```
Â¬ a <-> x åŒæ—¶æ»¡è¶³åŒå‘ç®­å¤´
Â¬ a <- x è‡³ (Â¬ a \/ Â¬x)     Â¬a -> x è‡³ a \/ x
Â¬ ğ‘ âˆ¨ Â¬ğ‘¥ âˆ§ (ğ‘ âˆ¨ ğ‘¥)
```

2. De Morgan's Lawï¼š æ¶ˆå»Â¬or å†…ç§»Â¬

```
Â¬(p âˆ¨ q)<=>(Â¬p) âˆ§ (Â¬q)
Â¬(p âˆ§ q)<=>(Â¬p) âˆ¨ (Â¬q)
```

### Example

1.

![image-20211212185340585](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211212185340585.png)

2. æ³¨æ„å¯¹å¦å•ç‹¬å–ä¸€åŒç®­å¤´è½¬æ¢

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211212185620604.png" alt="image-20211212185620604" style="zoom: 50%;" />

<img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211212185648998.png" alt="image-20211212185648998" style="zoom: 50%;" />

## L10-13 **AUTOMATED REASONING**

A formula where negation is applied only to propositional atoms is said to be in Negation Normal Form (NNF).

A formula that is a multiary conjunction of muliary disjunctions of literals is in conjunctive normal form (CNF).

A formula that is a multiary disjunction of multiary conjunctions of literals is in disjunctive normal form (DNF).

### :star:equisatisfiable ç­‰å¯ä»¥æ»¡è¶³çš„ 

**Given two formulas ğ‘‹ and ğ‘Œ, we say they are equisatisfiable if and only if ğ‘‹ is satisfiable if and only if ğ‘Œ is.**

If ğ‘‹ and ğ‘Œ are equisatisfiable, are they equivalent? :

**No. ğ‘‹ and ğ‘Œ are equisatisfiable but they are not equal.Equisatisfiability is weaker than equivalence**

###  :star:SAT Boolean satisfiability problem

**å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜**

**æ˜¯ç¡®å®šæ˜¯å¦å­˜åœ¨æ»¡è¶³ç»™å®šå¸ƒå°”å…¬å¼çš„è§£é‡Šçš„é—®é¢˜ã€‚** æ¢å¥è¯è¯´ï¼Œå®ƒè¯¢é—®ç»™å®šå¸ƒå°”å…¬å¼çš„å˜é‡æ˜¯å¦å¯ä»¥ä¸€è‡´åœ°ç”¨å€¼TRUEæˆ–FALSEæ›¿æ¢ï¼Œå…¬å¼è®¡ç®—ç»“æœä¸ºTRUEã€‚ å¦‚æœæ˜¯è¿™ç§æƒ…å†µï¼Œå…¬å¼ç§°ä¸ºå¯æ»¡è¶³ã€‚

Is the problem of determining whether there exists an interpretation that satisfies a given Boolean formula. In other words, it asks whether a variable given a Boolean formula can be consistently replaced with the value TRUE or FALSE, and the formula evaluates to TRUE. If this is the case, the formula is said to be satisfiable.

### :star:SMT satisfiability modulo theories

**å¯æ»¡è¶³æ€§æ¨¡å—ç†è®º**

SMTé—®é¢˜çš„åŸºç¡€æ˜¯ä¸€é˜¶é€»è¾‘å…¬å¼ï¼Œåœ¨å‘½é¢˜é€»è¾‘çš„åŸºç¡€ä¸Šè¡¥å……äº†é¡¹å’Œé‡è¯ï¼Œå…¬å¼ä¸­çš„å‡½æ•°å’Œè°“è¯ç¬¦å·éœ€è¦ç”¨å¯¹åº”çš„èƒŒæ™¯ç†è®ºè§£é‡Šã€‚**é€šå¸¸æƒ…å†µä¸‹ï¼ŒSMTå…¬å¼æ˜¯æ— é‡è¯(quantifier free formula)çš„ä¸€é˜¶é€»è¾‘å…¬å¼ï¼Œåˆ¤å®šå…¬å¼å¯æ»¡è¶³æ€§çš„é—®é¢˜ç§°ä¸ºSMTé—®é¢˜ã€‚**

The SMT problem is based on the first-order logic formula, which is supplemented with terms and quantifiers on the basis of propositional logic. The function and predicate symbols in the formula need to be explained by the corresponding background theory. **Generally, SMT formula is the first-order logical formula of quantifier free formula, and the problem of determining the satisfiability of formula is called SMT problem.**

 #### :star:Main difference between SAT solvers and SMT solvers

SAT solvers solve constraints involving(written in) propositional logic.

SMT solvers can solve constraints involving propositional logic. Additionally it can solve constraints involving(written in) predicate logic with quantifiers. In simple words, SMT solvers are more powerful than SAT solvers.

SAT æ±‚è§£å™¨è§£å†³æ¶‰åŠï¼ˆå†™å…¥ï¼‰å‘½é¢˜é€»è¾‘çš„çº¦æŸã€‚

SMT æ±‚è§£å™¨å¯ä»¥æ±‚è§£æ¶‰åŠå‘½é¢˜é€»è¾‘çš„çº¦æŸã€‚æ­¤å¤–ï¼Œå®ƒå¯ä»¥è§£å†³æ¶‰åŠï¼ˆå†™å…¥ï¼‰å¸¦æœ‰é‡è¯çš„è°“è¯é€»è¾‘çš„çº¦æŸã€‚ç®€å•æ¥è¯´ï¼ŒSMT æ±‚è§£å™¨æ¯” SAT æ±‚è§£å™¨æ›´å¼ºå¤§ã€‚

## L14-19:star:Hoare Logic éœå°”é€»è¾‘

### [Hoare Logic Examples](https://moodle.maynoothuniversity.ie/pluginfile.php/881719/mod_resource/content/1/Lectures%2014%20-%2015%20-%20Notes%20-%20Hoare%20Logic%20Examples.pdf)

#### ç®—æ•°è¡¨è¾¾å¼é‡è¯

![image-20211220200046631](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220200046631.png)

#### Using the Assign Rule åˆ†é…è§„åˆ™

æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬ä¸èƒ½è¯æ˜ç»™å®šçš„å‰ææ„å‘³ç€(æˆ–ç­‰ä»·äº)åœ¨æ­¥éª¤2ä¸­è®¡ç®—çš„å‰æï¼Œé‚£ä¹ˆç¨‹åºå°±ä¸èƒ½è¯æ˜ç»™å®šçš„å‰æå’Œåç½®æ¡ä»¶æ˜¯æ­£ç¡®çš„ã€‚

![image-20211216210336670](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210336670.png)

![image-20211216210424402](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210424402.png)

![image-20211216210436275](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210436275.png)

#### Using the composition rule åˆæˆè§„åˆ™

![image-20211216210523885](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210523885.png)

![image-20211216210649120](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210649120.png)

#### Using the rule for if statement ifè¯­å¥è§„åˆ™

![image-20211216210729713](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210729713.png)

![image-20211216210804559](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210804559.png)

![image-20211216210813781](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210813781.png)

![image-20211216210825943](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210825943.png)

![image-20211216210849223](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210849223.png)

#### ç»¼åˆç»ƒä¹ 

![image-20211216210908232](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210908232.png)

![image-20211216210928624](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216210928624.png)

![image-20211216211006711](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216211006711.png)

### Hoare Logic Loop

Finding variant expressions for loop Terminationï¼ˆå¯»æ‰¾å¾ªç¯ç»ˆæ­¢å˜é‡ï¼‰

1. 

![image-20211216211442219](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216211442219.png)

2.

![image-20211216211506720](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211216211506720.png)

## :star:Model checking (temporal logic) æ¨¡å‹æ ¡éªŒï¼ˆæ—¶é—´é€»è¾‘ï¼‰



### temporal logic

ä½¿ç”¨å­˜åœ¨é‡è¯æˆ–å…¨ç§°é‡è¯çš„ä»»ä½•é€»è¾‘éƒ½å«åšä¸€é˜¶é€»è¾‘ã€‚æŠŠæ—¶é—´çœ‹ä½œçŠ¶æ€çš„åºåˆ—çš„ä»»ä½•é€»è¾‘éƒ½æ˜¯æ—¶é—´é€»è¾‘ï¼Œåªä½¿ç”¨ä¸¤ä¸ªçœŸå€¼çš„ä»»ä½•é€»è¾‘éƒ½æ˜¯äºŒå€¼é€»è¾‘ã€‚

Any logic that uses existential or universal quantifiers is called first-order logic. Any logic that treats time as a sequence of states is temporal logic, and any logic that uses only two truth values is binary logic.

åœ¨æ—¶é—´é€»è¾‘ä¸­ï¼Œé™ˆè¿°å¯ä»¥æœ‰éšæ—¶é—´å˜åŒ–çš„çœŸå€¼ã€‚ä¸ä¹‹ç›¸å¯¹çš„æ˜¯éæ—¶é—´é€»è¾‘ï¼Œå®ƒåªèƒ½å¤„ç†æœ‰ç€éšæ—¶é—´æ’å®šçš„çœŸå€¼çš„é™ˆè¿°ã€‚

In temporal logic, statements can have truth values that vary over time.  In contrast, non-temporal logic can only deal with statements that have truth values constant over time.

æ—¶åºé€»è¾‘åœ¨å½¢å¼éªŒè¯ä¸­æœ‰ç€é‡è¦çš„åº”ç”¨ï¼Œç”¨äºè¯´æ˜ç¡¬ä»¶æˆ–è½¯ä»¶ç³»ç»Ÿçš„éœ€æ±‚ã€‚ä¾‹å¦‚ï¼Œäººä»¬å¯èƒ½æƒ³è¯´ï¼Œæ— è®ºä½•æ—¶å‘å‡ºè¯·æ±‚ï¼Œæœ€ç»ˆéƒ½ä¼šæˆäºˆå¯¹èµ„æºçš„è®¿é—®æƒé™ï¼Œä½†ç»ä¸ä¼šåŒæ—¶æˆäºˆä¸¤ä¸ªè¯·æ±‚è€…ã€‚è¿™æ ·çš„é™ˆè¿°å¯ä»¥æ–¹ä¾¿åœ°ç”¨æ—¶é—´é€»è¾‘æ¥è¡¨è¾¾ã€‚

The verification of these systems is done by providing a formal proof on an abstract mathematical model of the system, the correspondence between the mathematical model and the nature of the system being otherwise known by construction. Examples of mathematical objects often used to model systems are: finite state machines, labelled transition systems, Petri nets, vector addition systems, timed automata, hybrid automata, process algebra, formal semantics of programming languages such as operational semantics, denotational semantics, axiomatic semantics and Hoare logic.

## :star:Dafny

#### ç¨‹åº programmsï¼š

Dafnyç¨‹åºé•¿è¿™æ ·ï¼šxxxxx.dfyï¼ŒDafnyæ–‡ä»¶æ˜¯ä»¥dfyç»“å°¾çš„ã€‚

ç¨‹åºä¸»è¦åŒ…å«ä»¥ä¸‹å‡ éƒ¨åˆ†ï¼š

1. ç±»å‹(types)
2. æ–¹æ³•(methods)
3. å‡½æ•°(functions)
4. ç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å‹åŒ…æ‹¬ç±»ï¼ˆclassï¼‰å’Œå½’çº³æ•°æ®ç±»å‹(inductive class)
5. ç±»classæœ¬èº«ä¹ŸåŒ…å«ä¸€ç»„å£°æ˜(declarations)ã€ä»‹ç»å­—æ®µï¼ˆintroducing fieldsï¼‰ã€æ–¹æ³•(methods)å’Œå‡½æ•°(functions)ã€‚

å¦‚æœæœ‰mainæ–¹æ³•é‚£å°±ä»mainå¼€å§‹éªŒè¯ç¨‹åºï¼Œæ²¡æœ‰ä¹Ÿæ²¡å…³ç³»ï¼Œmainä¸æ˜¯å¿…é¡»çš„ã€‚

æ³¨é‡Šï¼š// åŒæ–œæ  æˆ–è€… / *xxxxx* /

**åŸºæœ¬å®šä¹‰**

åœ¨ç±»ä¸­ï¼Œå®šä¹‰å­—æ®µxä¸ºæ•°æ®ç±»å‹(types)Tï¼š

**var x: T**

æ³¨æ„äº‹é¡¹ï¼š

- æ•°æ®ç±»å‹å¿…éœ€æ‰‹åŠ¨ç”³æ˜çš„ï¼Œä¸ä¼šè¢«è‡ªåŠ¨æ¨æ–­ã€‚
- é€šè¿‡åœ¨å£°æ˜å‰åŠ ä¸Šå…³é”® **ghost** å¯ä»¥å°†è¯¥å­—æ®µå£°æ˜ä¸ºå¹½çµï¼ˆå³ç”¨äºè§„èŒƒ**è€Œä¸æ˜¯æ‰§è¡Œ**ï¼‰å­—æ®µã€‚

Dafny çš„9ç§æ•°æ®ç±»å‹åŒ…æ‹¬ï¼š

- boolï¼šå¸ƒå°”å€¼
- intï¼šæ— ç•Œæ•´æ•°
- string: å­—ç¬¦ä¸²
- class/inductive class: ç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å’Œå½’çº³ç±»ã€
- set<T>ï¼šä¸å¯å˜çš„æ— åºé›†åˆ
- seq<T>ï¼šä¸å¯å˜çš„æœ‰åºé›†åˆ
- array<T>ã€array2<T>ã€array3<T>: å¤šç»´æ•°ç»„ç±»å‹
- objectï¼šæ‰€æœ‰ç±»å‹çš„è¶…ç±»
- natï¼šèŒƒå›´æ˜¯intä¸€åŠï¼Œéè´Ÿæ•´æ•°ã€‚

#### Methods

Dafny åœ¨è®¸å¤šæ–¹é¢ç±»ä¼¼äºå…¸å‹çš„å‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€ã€‚æœ‰æ–¹æ³•ã€å˜é‡ã€ç±»å‹ã€å¾ªç¯ã€if è¯­å¥ã€æ•°ç»„ã€æ•´æ•°ç­‰ç­‰ã€‚ä»»ä½• Dafny ç¨‹åºçš„åŸºæœ¬å•å…ƒä¹‹ä¸€æ˜¯æ–¹æ³•ã€‚æ–¹æ³•æ˜¯ä¸€æ®µå‘½ä»¤å¼çš„ã€å¯æ‰§è¡Œçš„ä»£ç ã€‚åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œå®ƒä»¬å¯èƒ½è¢«ç§°ä¸ºè¿‡ç¨‹æˆ–å‡½æ•°ï¼Œä½†åœ¨ Dafny ä¸­ï¼Œæœ¯è¯­â€œå‡½æ•°â€æ˜¯ä¸ºä¸€ä¸ªä¸åŒçš„æ¦‚å¿µä¿ç•™çš„ï¼Œæˆ‘ä»¬å°†åœ¨åé¢ä»‹ç»ã€‚æ–¹æ³•çš„å£°æ˜æ–¹å¼å¦‚ä¸‹ï¼š

```java
method Abs(x: int) returns (y: int)
{
	...
}
```

è¿™å£°æ˜äº†ä¸€ä¸ªåä¸ºâ€œAbsâ€çš„æ–¹æ³•ï¼Œå®ƒæ¥å—ä¸€ä¸ªåä¸ºâ€œx â€çš„æ•´æ•°å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªåä¸ºâ€œ yâ€çš„æ•´æ•°ã€‚è¯·æ³¨æ„ï¼Œæ¯ä¸ªå‚æ•°å’Œè¿”å›å€¼éƒ½éœ€è¦ç±»å‹ï¼Œå¹¶åœ¨å†’å· ( :)åè·Ÿåœ¨æ¯ä¸ªåç§°ä¹‹åã€‚æ­¤å¤–ï¼Œè¿”å›å€¼æ˜¯å‘½åçš„ï¼Œå¹¶ä¸”å¯ä»¥æœ‰å¤šä¸ªè¿”å›å€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```java
method MultipleReturns(x: int,y int) returns(more: int,less: int)
{
	...
}
```

æ–¹æ³•ä½“æ˜¯åŒ…å«åœ¨å¤§æ‹¬å·å†…çš„ä»£ç ï¼Œç›´åˆ°ç°åœ¨å®ƒè¢«å·§å¦™åœ°è¡¨ç¤ºä¸ºâ€œ â€¦ â€ï¼ˆè¿™ä¸æ˜¯Dafny è¯­æ³•ï¼‰ã€‚ä¸»ä½“ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œä¾‹å¦‚ç†Ÿæ‚‰çš„å‘½ä»¤å¼èµ‹å€¼ã€ifè¯­å¥ã€å¾ªç¯ã€å…¶ä»–æ–¹æ³•è°ƒç”¨ã€è¿”å›è¯­å¥ç­‰ï¼Œä¾‹å¦‚æ–¹æ³•å¯ä»¥å®ç°ä¸ºï¼š

```java
method MultipleReturns(x: int,y: int) returns (more: int,less: int)
{
	more := x + y;
	less := x - y;
}
```

èµ‹å€¼ä½¿ç”¨â€œ:=â€è€Œä¸æ˜¯â€œ=â€ï¼Œç®€å•çš„è¯­å¥åè¾¹è·Ÿç€åˆ†å·ï¼Œç©ºæ ¼å’Œæ³¨é‡Šå¯ä»¥è¢«å¿½ç•¥ã€‚

è¿”å›å€¼ï¼š

```java
method Abs(x: int) returns (y: int)
{
	if x < 0
		{ return -x; }
	else
		{ return x; }
}
```

ä¸€ä¸ªè­¦å‘Šæ˜¯ä»–ä»¬æ€»æ˜¯éœ€è¦åœ¨åˆ†æ”¯å‘¨å›´ä½¿ç”¨å¤§æ‹¬å·ï¼Œå³ä½¿åˆ†æ”¯åªåŒ…å«ä¸€ä¸ªè¯­å¥ï¼ˆå¤åˆæˆ–å…¶ä»–ï¼‰ã€‚

#### å‰ç½®æ¡ä»¶ä¸åç½®æ¡ä»¶ Preconditions and postconditions

##### ensures åç½®æ¡ä»¶å£°æ˜

Dafny çš„çœŸæ­£åŠ›é‡æ¥è‡ªäºå¯¹è¿™äº›æ–¹æ³•è¿›è¡Œæ³¨é‡Šä»¥æŒ‡å®šå…¶è¡Œä¸ºçš„èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°çš„ä¸€ä¸ªå±æ€§Absæ–¹æ³•æ˜¯æ— è®ºè¾“å…¥å¦‚ä½•ï¼Œç»“æœå§‹ç»ˆå¤§äºæˆ–ç­‰äºé›¶ã€‚æœ‰å‡ ç§æ–¹æ³•å¯ä»¥ç»™å‡ºæ³¨è§£ï¼Œä½†ä¸€äº›æœ€å¸¸è§å’Œæœ€åŸºæœ¬çš„æ˜¯æ–¹æ³•å‰ç½® å’Œåç½®æ¡ä»¶ã€‚

æ–¹æ³•çš„è¿™ä¸ªå±æ€§Absï¼Œå³ç»“æœæ€»æ˜¯éè´Ÿçš„ï¼Œæ˜¯åç½®æ¡ä»¶çš„ä¸€ä¸ªä¾‹å­ï¼š**å®ƒåœ¨æ–¹æ³•è¿”å›åä¸ºçœŸ**ã€‚**ä½¿ç”¨ensures å…³é”®å­—å£°æ˜çš„åç½®æ¡ä»¶ä½œä¸ºæ–¹æ³•å£°æ˜çš„ä¸€éƒ¨åˆ†åœ¨è¿”å›å€¼ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ä¹‹åå’Œæ–¹æ³•ä¸»ä½“ä¹‹å‰ç»™å‡ºã€‚**

```java
method Abs(x: int) return (y: int)
	ensures 0 <= y
{
	...
}
```

ä½ å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ä¸ºä»€ä¹ˆè¿”å›å€¼è¢«èµ‹äºˆåç§°ã€‚è¿™ä½¿å¾—å®ƒä»¬å¾ˆå®¹æ˜“åœ¨æ–¹æ³•çš„åç½®æ¡ä»¶ä¸­å¼•ç”¨ã€‚å½“è¡¨è¾¾å¼ä¸ºçœŸæ—¶ï¼Œæˆ‘ä»¬è¯´åç½®æ¡ä»¶æˆç«‹ã€‚åç½®æ¡ä»¶å¿…é¡»é€‚ç”¨äºå‡½æ•°çš„æ¯æ¬¡è°ƒç”¨å’Œæ¯ä¸ªå¯èƒ½çš„è¿”å›ç‚¹ï¼ˆåŒ…æ‹¬å‡½æ•°ä½“æœ«å°¾çš„éšå¼è¿”å›ç‚¹ï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¡¨è¾¾çš„å”¯ä¸€å±æ€§æ˜¯è¿”å›å€¼å§‹ç»ˆè‡³å°‘ä¸ºé›¶ã€‚

æœ‰æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸ºæˆ‘ä»¬çš„ä»£ç å»ºç«‹å¤šä¸ªå±æ€§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªé€‰æ‹©ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¸ƒå°”å€¼å’Œè¿ç®—ç¬¦ ( )å°†è¿™ä¸¤ä¸ªæ¡ä»¶è¿æ¥åœ¨ä¸€èµ·ï¼Œä¹Ÿå¯ä»¥ç¼–å†™å¤šä¸ªè§„èŒƒã€‚åè€…ä¸å‰è€…åŸºæœ¬ç›¸åŒï¼Œä½†æ€§è´¨ä¸åŒã€‚

```java
method MultipleReturns(x: int, y: int) returns (more: int, less: int)
   ensures less < x
   ensures x < more
{
   more := x + y;
   less := x - y;
}
```

åç½®æ¡ä»¶ä¹Ÿå¯ä»¥å†™æˆï¼š

```
ensures less < x && x < more
```

ç”šè‡³

```
ensures less < x < more
```

Dafny å®é™…ä¸Šæ‹’ç»äº†è¿™ä¸ªç¨‹åºï¼Œå£°ç§°ç¬¬ä¸€ä¸ªåç½®æ¡ä»¶ä¸æˆç«‹ï¼ˆå³ä¸æˆç«‹ï¼‰ã€‚è¿™æ„å‘³ç€ Dafny æ— æ³•è¯æ˜æ¯æ¬¡æ–¹æ³•è¿”å›æ—¶æ­¤æ³¨é‡Šéƒ½æˆç«‹ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯¼è‡´ Dafny éªŒè¯é”™è¯¯çš„ä¸»è¦åŸå› æœ‰ä¸¤ä¸ªï¼šä¸ä»£ç ä¸ä¸€è‡´çš„è§„èŒƒï¼Œä»¥åŠå®ƒä¸å¤Ÿâ€œèªæ˜â€ä»¥è¯æ˜æ‰€éœ€å±æ€§çš„æƒ…å†µã€‚åŒºåˆ†è¿™ä¸¤ç§å¯èƒ½æ€§å¯èƒ½æ˜¯ä¸€é¡¹è‰°å·¨çš„ä»»åŠ¡ï¼Œä½†å¹¸è¿çš„æ˜¯ï¼ŒDafny å’Œå®ƒæ‰€åŸºäºçš„ Boogie/Z3 ç³»ç»Ÿéå¸¸èªæ˜ï¼Œå¹¶ä¸”å°†è¯æ˜ä»£ç å’Œè§„èŒƒç›¸åŒ¹é…è€Œä¸ä¼šå¤§æƒŠå°æ€ªã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒDafny è¯´ä»£ç æœ‰é”™è¯¯æ˜¯æ­£ç¡®çš„ã€‚é—®é¢˜çš„å…³é”®æ˜¯å®ƒy æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œæ‰€ä»¥å®ƒå¯ä»¥æ˜¯è´Ÿæ•°ã€‚å¦‚æœyä¸ºè´Ÿï¼ˆæˆ–é›¶ï¼‰ï¼Œåˆ™more å®é™…ä¸Šå¯ä»¥å°äºæˆ–ç­‰äºxã€‚é™¤éyä¸¥æ ¼å¤§äºé›¶ï¼Œå¦åˆ™æˆ‘ä»¬çš„æ–¹æ³•ä¸ä¼šæŒ‰é¢„æœŸå·¥ä½œã€‚è¿™æ°æ°æ˜¯ä¸€ä¸ªå‰æçš„æƒ³æ³•ã€‚å‰ç½®æ¡ä»¶ä¸åç½®æ¡ä»¶ç±»ä¼¼ï¼Œä¸åŒä¹‹å¤„åœ¨äºå®ƒä¹‹å‰å¿…é¡»ä¸ºçœŸ ä¸€ä¸ªæ–¹æ³•è¢«è°ƒç”¨ã€‚å½“ä½ è°ƒç”¨ä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œä½ çš„å·¥ä½œæ˜¯å»ºç«‹ï¼ˆä½¿ï¼‰å…ˆå†³æ¡ä»¶ï¼ŒDafny å°†ä½¿ç”¨è¯æ˜æ¥å¼ºåˆ¶æ‰§è¡Œã€‚åŒæ ·ï¼Œå½“æ‚¨ç¼–å†™æ–¹æ³•æ—¶ï¼Œæ‚¨å¯ä»¥å‡è®¾å‰ææ¡ä»¶ï¼Œä½†å¿…é¡»å»ºç«‹åç½®æ¡ä»¶ã€‚æ–¹æ³•çš„è°ƒç”¨è€…ç„¶åå‡è®¾åç½®æ¡ä»¶åœ¨æ–¹æ³•è¿”å›åæˆç«‹ã€‚

##### å‰ç½®æ¡ä»¶ requires

**å…ˆå†³æ¡ä»¶æœ‰è‡ªå·±çš„å…³é”®å­—ï¼Œrequires**ã€‚æˆ‘ä»¬å¯ä»¥ç»™å‡ºå¿…è¦çš„å‰ææ¡ä»¶MultipleReturns å¦‚ä¸‹ï¼š

```java
method MultipleReturns(x: int, y: int) returns (more: int, less: int)
   requires 0 < y
   ensures less < x < more
{
   more := x + y;
   less := x - y;
}
```

#### æ–­è¨€ assert
ä¸å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶ä¸åŒï¼Œæ–­è¨€æ”¾ç½®åœ¨æ–¹æ³•ä¸­é—´çš„æŸä¸ªä½ç½®ã€‚ä¸å‰ä¸¤ä¸ªæ³¨é‡Šä¸€æ ·ï¼Œæ–­è¨€æœ‰ä¸€ä¸ªå…³é”®å­—assertï¼Œåè·Ÿå¸ƒå°”è¡¨è¾¾å¼å’Œç»ˆæ­¢ç®€å•è¯­å¥çš„åˆ†å·ã€‚æ–­è¨€è¯´å½“æ§åˆ¶åˆ°è¾¾ä»£ç çš„é‚£éƒ¨åˆ†æ—¶ï¼Œç‰¹å®šçš„è¡¨è¾¾å¼æ€»æ˜¯æˆç«‹ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯åœ¨è™šæ‹Ÿæ–¹æ³•ä¸­ç®€å•ä½¿ç”¨æ–­è¨€ï¼š

```java
method Testing()
{
   assert 2 < 3;
}
```

Dafny è¯æ˜äº†è¿™ç§æ–¹æ³•æ˜¯æ­£ç¡®çš„ï¼Œå› ä¸º 2 æ€»æ˜¯å°äº 3ã€‚æ–­è¨€æœ‰å¤šç§ç”¨é€”ï¼Œä½†å…¶ä¸­æœ€ä¸»è¦çš„æ˜¯æ£€æŸ¥æ‚¨å¯¹ä¸åŒç‚¹çš„çœŸå®æœŸæœ›æ˜¯å¦çœŸçš„æ˜¯çœŸå®çš„ã€‚æ‚¨å¯ä»¥ä½¿ç”¨å®ƒæ¥æ£€æŸ¥åŸºæœ¬çš„ç®—æœ¯äº‹å®ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼Œä½†å®ƒä»¬ä¹Ÿå¯ä»¥ç”¨äºæ›´å¤æ‚çš„æƒ…å†µã€‚æ–­è¨€æ˜¯è°ƒè¯•æ³¨é‡Šçš„å¼ºå¤§å·¥å…·ï¼Œé€šè¿‡æ£€æŸ¥ Dafny èƒ½å¤Ÿè¯æ˜æ‚¨çš„ä»£ç çš„å†…å®¹ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥è°ƒæŸ¥ Dafny å¯¹Abså‡½æ•°çš„äº†è§£ã€‚

## å£°æ˜å˜é‡

```
var x: int := 5;
```

åœ¨è¿™ç§æƒ…å†µä¸‹å¯ä»¥åˆ é™¤ç±»å‹æ³¨é‡Šï¼š(intçœç•¥)

```
var x := 5;
```

å¯ä»¥ä¸€æ¬¡å£°æ˜å¤šä¸ªå˜é‡ï¼š

```
var x, y, z: bool := 1, 2, true;
```

æ˜¾å¼ç±»å‹å£°æ˜ä»…é€‚ç”¨äºç´§æ¥åœ¨å‰é¢çš„å˜é‡ï¼Œå› æ­¤è¿™é‡Œçš„boolå£°æ˜ä»…é€‚ç”¨äºzï¼Œè€Œä¸é€‚ç”¨äºxæˆ–yï¼Œå®ƒä»¬éƒ½è¢«æ¨æ–­ä¸ºintsã€‚æˆ‘ä»¬éœ€è¦å˜é‡æ˜¯å› ä¸ºæˆ‘ä»¬æƒ³è®¨è®ºAbs æ–¹æ³•çš„è¿”å›å€¼ã€‚æˆ‘ä»¬ä¸èƒ½Absç›´æ¥æ”¾å…¥è§„èŒƒï¼Œå› ä¸ºè¯¥æ–¹æ³•å¯èƒ½ä¼šæ”¹å˜å†…å­˜çŠ¶æ€ç­‰é—®é¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬æ•è·è°ƒç”¨çš„è¿”å›å€¼Abså¦‚ä¸‹ï¼š

```java
method Testing()
{
   var v := Abs(3);
   assert 0 <= v;
}
```

#### å‡½æ•° Function

```typescript
function abs(x: int): int
{
   ...
}
```

è¿™å£°æ˜äº†ä¸€ä¸ªè¢«è°ƒç”¨çš„å‡½æ•°absï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ•´æ•°ï¼ˆç¬¬äºŒä¸ªintï¼‰ï¼Œä¸åœ¨å…¶ä¸»ä½“ä¸­å¯ä»¥åŒ…å«å„ç§è¯­å¥çš„æ–¹æ³•ä¸åŒï¼Œå‡½æ•°ä¸»ä½“å¿…é¡»ä»…åŒ…å«ä¸€ä¸ªå…·æœ‰æ­£ç¡®ç±»å‹çš„è¡¨è¾¾å¼ã€‚è¿™é‡Œæˆ‘ä»¬çš„ body å¿…é¡»æ˜¯ä¸€ä¸ªæ•´æ•°è¡¨è¾¾å¼ã€‚ä¸ºäº†å®ç°ç»å¯¹å€¼å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨if è¡¨è¾¾å¼ã€‚if è¡¨è¾¾å¼ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„ä¸‰å…ƒè¿ç®—ç¬¦ã€‚

```ts
function abs(x: int): int
{
   if x < 0 then -x else x
}
```

é‚£ä¹ˆä¸ºä»€ä¹ˆè¦ç”¨å‡½æ•°è€Œä¸ç”¨æ–¹æ³•å‘¢ï¼Œå…³é”®åœ¨äºå‡½æ•°å¯ä»¥åœ¨è§„èŒƒä¸­ç›´æ¥ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆå†™ï¼š

```ts
assert abs(3) == 3;
```

äº‹å®ä¸Šï¼Œæˆ‘ä»¬ä¸ä»…å¯ä»¥ç›´æ¥ç¼–å†™è¿™ä¸ªè¯­å¥è€Œä¸æ•è·åˆ°å±€éƒ¨å˜é‡ï¼Œæˆ‘ä»¬ç”šè‡³ä¸éœ€è¦ç¼–å†™æˆ‘ä»¬ä½¿ç”¨è¯¥æ–¹æ³•æ‰€åšçš„æ‰€æœ‰åç½®æ¡ä»¶ï¼ˆå°½ç®¡é€šå¸¸å‡½æ•°å¯ä»¥å¹¶ä¸”ç¡®å®å…·æœ‰å‰ç½®å’Œåç½®æ¡ä»¶ï¼‰ã€‚åŠŸèƒ½çš„é™åˆ¶æ­£æ˜¯è®© Dafny åšåˆ°è¿™ä¸€ç‚¹çš„åŸå› ã€‚ä¸æ–¹æ³•ä¸åŒï¼ŒDafny åœ¨è€ƒè™‘å…¶ä»–å‡½æ•°æ—¶ä¸ä¼šå¿˜è®°å‡½æ•°ä½“ã€‚æ‰€ä»¥å®ƒå¯ä»¥æ‰©å±•ä¸Šé¢æ–­è¨€ä¸­absçš„å®šä¹‰ï¼Œç¡®å®šç»“æœå®é™…ä¸Šæ˜¯3ã€‚

## å¾ªç¯ä¸å˜é‡ invariant

è™½ç„¶å¾ªç¯ç»™ Dafny å¸¦æ¥äº†é—®é¢˜ã€‚Dafny æ— æ³•æå‰çŸ¥é“ä»£ç å°†åœ¨å¾ªç¯ä¸­è¿è¡Œå¤šå°‘æ¬¡ã€‚ä½†æ˜¯ Dafny éœ€è¦è€ƒè™‘é€šè¿‡ç¨‹åºçš„æ‰€æœ‰è·¯å¾„ï¼Œå…¶ä¸­å¯èƒ½åŒ…æ‹¬å¤šæ¬¡å¾ªç¯ã€‚ä¸ºäº†è®© Dafny èƒ½å¤Ÿä½¿ç”¨å¾ªç¯ï¼Œæ‚¨éœ€è¦æä¾›å¾ªç¯ä¸å˜é‡ï¼Œå¦ä¸€ç§æ³¨é‡Šã€‚

**å¾ªç¯ä¸å˜é‡æ˜¯åœ¨è¿›å…¥å¾ªç¯æ—¶ä»¥åŠåœ¨æ¯æ¬¡æ‰§è¡Œå¾ªç¯ä½“ä¹‹åä¿æŒä¸å˜çš„è¡¨è¾¾å¼ã€‚ä¸å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶ä¸€æ ·ï¼Œä¸å˜é‡æ˜¯ä¸ºå¾ªç¯çš„æ¯æ¬¡æ‰§è¡Œä¿ç•™çš„å±æ€§ï¼Œä½¿ç”¨æˆ‘ä»¬è§è¿‡çš„ç›¸åŒå¸ƒå°”è¡¨è¾¾å¼è¡¨ç¤ºã€‚**ä¾‹å¦‚ï¼Œæˆ‘ä»¬åœ¨ä¸Šé¢çš„å¾ªç¯ä¸­çœ‹åˆ°ï¼Œå¦‚æœi å¼€å§‹ä¸ºæ­£å€¼ï¼Œåˆ™å®ƒä¿æŒæ­£å€¼ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒè‡ªå·±çš„å…³é”®å­—å°†ä¸å˜é‡æ·»åŠ åˆ°å¾ªç¯ä¸­ï¼š

```ts
var i := 0;
while i < n
   invariant 0 <= i
{
   i := i + 1;
}
```

å½“æ‚¨æŒ‡å®šä¸€ä¸ªä¸å˜é‡æ—¶ï¼ŒDafny è¯æ˜äº†ä¸¤ä»¶äº‹ï¼šè¯¥ä¸å˜é‡åœ¨è¿›å…¥å¾ªç¯æ—¶ä¿æŒä¸å˜ï¼Œå¹¶ä¸”ç”±å¾ªç¯ä¿ç•™ã€‚ä¿ç•™ï¼Œæˆ‘ä»¬çš„æ„æ€æ˜¯å‡è®¾ä¸å˜é‡åœ¨å¾ªç¯å¼€å§‹æ—¶æˆç«‹ï¼Œ**æˆ‘ä»¬å¿…é¡»è¯æ˜æ‰§è¡Œä¸€æ¬¡å¾ªç¯ä½“ä¼šä½¿ä¸å˜é‡å†æ¬¡æˆç«‹ã€‚**

#### ç»ˆæ­¢ decreaseså‡å°‘

Dafny é€šè¿‡ä½¿ç”¨decreaseè¿™ä¸ªæ³¨é‡Šè¯æ˜ä»£ç ç»ˆæ­¢ï¼Œå³ä¸ä¼šæ°¸è¿œå¾ªç¯ã€‚å¯¹äºå¾ˆå¤šäº‹æƒ…ï¼ŒDafny èƒ½å¤ŸçŒœå‡ºæ­£ç¡®çš„æ³¨é‡Šï¼Œä½†æœ‰æ—¶éœ€è¦æ˜ç¡®è¯´æ˜ã€‚äº‹å®ä¸Šï¼Œå¯¹äºæˆ‘ä»¬ç›®å‰çœ‹åˆ°çš„æ‰€æœ‰ä»£ç ï¼ŒDafny å·²ç»èƒ½å¤Ÿè‡ªå·±åšè¿™ä¸ªè¯æ˜ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬è¿˜æ²¡æœ‰æ˜ç¡®çœ‹åˆ°decreaseæ³¨é‡Šçš„åŸå› ã€‚Dafny è¯æ˜ç»ˆæ­¢æœ‰ä¸¤ä¸ªåœ°æ–¹ï¼šå¾ªç¯å’Œé€’å½’ã€‚è¿™ä¸¤ç§æƒ…å†µéƒ½éœ€è¦æ˜ç¡®çš„æ³¨é‡Šæˆ– Dafny çš„æ­£ç¡®çŒœæµ‹ã€‚

é¡¾åæ€ä¹‰ï¼Œé€’å‡æ³¨é‡Šç»™å‡ºäº†éšç€æ¯æ¬¡å¾ªç¯è¿­ä»£æˆ–é€’å½’è°ƒç”¨è€Œé€’å‡çš„ Dafny å’Œè¡¨è¾¾å¼ã€‚**Dafny åœ¨ä½¿ç”¨é€’å‡è¡¨è¾¾å¼æ—¶éœ€è¦éªŒè¯ä¸¤ä¸ªæ¡ä»¶ï¼šè¡¨è¾¾å¼å®é™…ä¸Šå˜å°äº†ï¼Œå¹¶ä¸”å®ƒæ˜¯æœ‰ç•Œçš„ã€‚**å¾ˆå¤šæ—¶å€™ï¼Œæ•´æ•°å€¼ï¼ˆè‡ªç„¶æˆ–æ™®é€šæ•´æ•°ï¼‰æ˜¯å‡å°‘çš„æ•°é‡ï¼Œä½†ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–ä¸œè¥¿ã€‚ï¼ˆæœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…å‚è€ƒèµ„æ–™ã€‚ï¼‰å¯¹äºæ•´æ•°ï¼Œå‡å®šç•Œé™ä¸ºé›¶ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯å¾ªç¯ä¸­å‡å°‘çš„æ­£ç¡®ä½¿ç”¨ï¼ˆå½“ç„¶æœ‰è‡ªå·±çš„å…³é”®å­—ï¼‰ï¼š

```ts
	while 0 < i
      invariant 0 <= i
      decreases i
   {
      i := i - 1;
   }
```

åœ¨è¿™é‡Œï¼ŒDafny æ‹¥æœ‰è¯æ˜ç»ˆæ­¢æ‰€éœ€çš„æ‰€æœ‰è¦ç´ ã€‚iæ¯æ¬¡å¾ªç¯è¿­ä»£è¯¥å˜é‡éƒ½ä¼šå˜å°ï¼Œå¹¶ä¸”ä¸‹é™ä¸ºé›¶ã€‚è¿™å¾ˆå¥½ï¼Œé™¤äº†å¾ªç¯æ˜¯ä»å¤§å¤šæ•°å¾ªç¯å‘åè®¡æ•°çš„ï¼Œè¿™äº›å¾ªç¯å€¾å‘äºå‘ä¸Šè®¡æ•°è€Œä¸æ˜¯å‘ä¸‹è®¡æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå‡å°‘çš„ä¸æ˜¯è®¡æ•°å™¨æœ¬èº«ï¼Œè€Œæ˜¯è®¡æ•°å™¨ä¸ä¸Šé™ä¹‹é—´çš„è·ç¦»ã€‚ä¸‹é¢ç»™å‡ºäº†å¤„ç†è¿™ç§æƒ…å†µçš„ç®€å•æŠ€å·§ï¼š

```ts
while i < n
  invariant 0 <= i <= n
  decreases n - i
 {
      i := i + 1;
 }
```

è¿™å®é™…ä¸Šæ˜¯ Dafny å¯¹è¿™ç§æƒ…å†µçš„çŒœæµ‹ï¼Œå› ä¸ºå®ƒçœ‹åˆ°å¹¶å‡è®¾n-iæ˜¯å‡å°‘çš„æ•°é‡ã€‚

#### æ•°ç»„

æ•°ç»„æ˜¯è¯­è¨€çš„å†…ç½®éƒ¨åˆ†ï¼Œæœ‰è‡ªå·±çš„ç±»å‹array,å…¶ä¸­Tæ˜¯å¦ä¸€ç§ç±»å‹ã€‚ç°åœ¨æˆ‘ä»¬åªè€ƒè™‘æ•´æ•°æ•°ç»„ï¼Œæ•°ç»„å¯ä»¥æ˜¯ç©ºï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªå†…ç½®çš„é•¿åº¦å­—æ®µa.Lengthã€‚å¿…é¡»è¯æ˜æ‰€æœ‰æ•°ç»„è®¿é—®éƒ½åœ¨è¾¹ç•Œå†…ï¼Œè¿™æ˜¯ Dafny æ— è¿è¡Œæ—¶é”™è¯¯å®‰å…¨ä¿è¯çš„ä¸€éƒ¨åˆ†ã€‚è¦åˆ›å»ºä¸€ä¸ªæ–°æ•°ç»„ï¼Œå¿…é¡»ç”¨newå…³é”®å­—åˆ†é…å®ƒï¼Œä½†ç°åœ¨æˆ‘ä»¬åªä½¿ç”¨å°†å…ˆå‰åˆ†é…çš„æ•°ç»„ä½œä¸ºå‚æ•°çš„æ–¹æ³•ã€‚
æˆ‘ä»¬å¯èƒ½æƒ³è¦å¯¹æ•°ç»„åšçš„æœ€åŸºæœ¬çš„äº‹æƒ…ä¹‹ä¸€æ˜¯æœç´¢å®ƒä»¥æŸ¥æ‰¾ç‰¹å®šçš„é”®ï¼Œå¹¶è¿”å›æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°é”®çš„ä½ç½®çš„ç´¢å¼•ï¼ˆå¦‚æœå®ƒå­˜åœ¨ï¼‰ã€‚æˆ‘ä»¬æœ‰ä¸¤ä¸ªæœç´¢ç»“æœï¼Œæ¯ä¸ªç»“æœéƒ½æœ‰ä¸åŒçš„æ­£ç¡®æ€§æ¡ä»¶ã€‚å¦‚æœç®—æ³•è¿”å›ä¸€ä¸ªç´¢å¼•ï¼ˆå³éè´Ÿæ•´æ•°ï¼‰ï¼Œé‚£ä¹ˆè¯¥é”®åº”è¯¥å‡ºç°åœ¨è¯¥ç´¢å¼•å¤„ã€‚è¿™å¯ä»¥è¡¨ç¤ºå¦‚ä¸‹ï¼š

```ts
method Find(a: array<int>, key: int) returns (index: int)
   ensures 0 <= index ==> index < a.Length && a[index] == key
{
   // Open in editor for a challenge...
}
```

è¿™é‡Œçš„æ•°ç»„ç´¢å¼•æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºè•´æ¶µè¿ç®—ç¬¦æ˜¯çŸ­è·¯çš„ã€‚çŸ­è·¯æ˜¯æŒ‡å¦‚æœå·¦è¾¹çš„éƒ¨åˆ†ä¸ºå‡ï¼Œé‚£ä¹ˆä¸ç®¡ç¬¬äºŒéƒ¨åˆ†çš„çœŸå€¼å¦‚ä½•ï¼Œè•´æ¶µéƒ½å·²ç»ä¸ºçœŸï¼Œå› æ­¤ä¸éœ€è¦å¯¹å…¶è¿›è¡Œè¯„ä¼°ã€‚

#### é‡è¯ forall

Dafny ä¸­çš„é‡è¯é€šå¸¸é‡‡ç”¨forallè¡¨è¾¾å¼çš„å½¢å¼ï¼Œä¹Ÿç§°ä¸ºå…¨ç§°é‡è¯ã€‚é¡¾åæ€ä¹‰ï¼Œ**å¦‚æœæŸä¸ªå±æ€§å¯¹æŸä¸ªé›†åˆçš„æ‰€æœ‰å…ƒç´ éƒ½æˆç«‹ï¼Œåˆ™è¯¥è¡¨è¾¾å¼ä¸ºçœŸ**ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†è€ƒè™‘æ•´æ•°é›†ã€‚ä¸‹é¢ç»™å‡ºäº†ä¸€ä¸ªåŒ…å«åœ¨æ–­è¨€ä¸­çš„å…¨ç§°é‡è¯ç¤ºä¾‹ï¼š

```ts
assert forall k :: k < k + 1;
```

é‡è¯ä¸ºå…¶è€ƒè™‘çš„é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ å¼•å…¥ä¸€ä¸ªä¸´æ—¶åç§°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ç§°ä¸ºç»‘å®šå˜é‡kã€‚ç»‘å®šå˜é‡æœ‰ä¸€ä¸ªç±»å‹ï¼Œå®ƒå‡ ä¹æ€»æ˜¯è¢«æ¨æ–­è€Œä¸æ˜¯æ˜¾å¼ç»™å‡ºï¼Œå¹¶ä¸”é€šå¸¸æ˜¯intæ— è®ºå¦‚ä½•ã€‚ä¸€å¯¹å†’å·(::)å°†ç»‘å®šå˜é‡åŠå…¶å¯é€‰ç±»å‹ä¸é‡åŒ–å±æ€§(å¿…é¡»æ˜¯boolç±»å‹)åˆ†éš”å¼€æ¥ã€‚é€šå¸¸ï¼Œé‡åŒ–æ— é™é›†ï¼ˆä¾‹å¦‚æ‰€æœ‰æ•´æ•°ï¼‰å¹¶ä¸æ˜¯å¾ˆæœ‰ç”¨ã€‚ç›¸åï¼Œé‡è¯é€šå¸¸ç”¨äºé‡åŒ–æ•°ç»„æˆ–æ•°æ®ç»“æ„ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚æˆ‘ä»¬é€šè¿‡ä½¿ç”¨è•´æ¶µè¿ç®—ç¬¦å¯¹æ•°ç»„æ‰§è¡Œæ­¤æ“ä½œï¼Œä½¿é‡åŒ–å±æ€§å¯¹äºä¸æ˜¯ç´¢å¼•çš„å€¼éå¸¸æ­£ç¡®ã€‚

```ts
assert forall k :: 0 <= k < a.Length ==> ...a[k]...;
```

è¿™è¡¨ç¤ºæ•°ç»„çš„æ¯ä¸ªå…ƒç´ éƒ½æœ‰ä¸€äº›å±æ€§ã€‚è¿™æ„å‘³ç€kåœ¨è¯„ä¼°è¡¨è¾¾å¼çš„ç¬¬äºŒéƒ¨åˆ†ä¹‹å‰ç¡®ä¿å®ƒå®é™…ä¸Šæ˜¯æ•°ç»„ä¸­çš„æœ‰æ•ˆç´¢å¼•ã€‚Dafny ä¸ä»…å¯ä»¥ä½¿ç”¨è¿™ä¸ªäº‹å®æ¥è¯æ˜æ•°ç»„æ˜¯å®‰å…¨è®¿é—®çš„ï¼Œè€Œä¸”è¿˜å¯ä»¥å°†å®ƒå¿…é¡»è€ƒè™‘çš„æ•´æ•°é›†å‡å°‘åˆ°ä»…ä½œä¸ºæ•°ç»„ç´¢å¼•çš„æ•´æ•°é›†ã€‚

ä½¿ç”¨é‡è¯ï¼Œè¯´é”®ä¸åœ¨æ•°ç»„ä¸­å¾ˆç®€å•ï¼š

```ts
forall k :: 0 <= k < a.Length ==> a[k] != key
```

å› æ­¤ï¼Œæˆ‘ä»¬çš„æ–¹æ³•åç½®æ¡ä»¶å˜ä¸ºï¼š

```ts
method Find(a: array<int>, key: int) returns (index: int)
   ensures 0 <= index ==> index < a.Length && a[index] == key
   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key
{
   ...
}
```

æˆ‘ä»¬å¯ä»¥é€šè¿‡å¤šç§æ–¹å¼å¡«å……æ­¤æ–¹æ³•çš„ä¸»ä½“ï¼Œä½†ä¹Ÿè®¸æœ€ç®€å•çš„æ˜¯çº¿æ€§æœç´¢ï¼Œå®ç°å¦‚ä¸‹ï¼š

```java
index := 0;
   while index < a.Length
   {
      if a[index] == key { return; }
      index := index + 1;
   }
   index := -1;
```

å¦‚æ‚¨æ‰€è§ï¼Œæˆ‘ä»¬åœ¨ while å¾ªç¯ä¸­çœç•¥äº†å¾ªç¯ä¸å˜é‡ï¼Œå› æ­¤ Dafny åœ¨å…¶ä¸­ä¸€ä¸ªåç½®æ¡ä»¶ä¸Šç»™äº†æˆ‘ä»¬ä¸€ä¸ªéªŒè¯é”™è¯¯ã€‚æˆ‘ä»¬å¾—åˆ°é”™è¯¯çš„åŸå› æ˜¯ Dafny ä¸çŸ¥é“å¾ªç¯å®é™…ä¸Šæ¶µç›–äº†æ‰€æœ‰å…ƒç´ ã€‚ä¸ºäº†è®© Dafny ç›¸ä¿¡è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¿…é¡»ç¼–å†™ä¸€ä¸ªä¸å˜é‡ï¼Œè¯´æ˜å½“å‰ç´¢å¼•ä¹‹å‰çš„æ‰€æœ‰å†…å®¹éƒ½å·²è¢«æŸ¥çœ‹ï¼ˆå¹¶ä¸”ä¸æ˜¯é”®ï¼‰ã€‚å°±åƒåç½®æ¡ä»¶ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨é‡è¯æ¥è¡¨è¾¾è¿™ä¸ªå±æ€§ï¼š

```java
invariant forall k :: 0 <= k < index ==> a[k] != key
```

æœ€ç»ˆä»£ç ï¼š

```java
method Find(a: array<int>, key: int) returns (index: int)
   ensures 0 <= index ==> index < a.Length && a[index] == key
   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key
{
   index := 0;
   while index < a.Length
      invariant 0 <= index <= a.Length
      invariant forall k :: 0 <= k < index ==> a[k] != key
   {
      if a[index] == key { return; }
      index := index + 1;
   }
   index := -1;
}
```

#### Class ç±»

ä¸€ä¸ªç±»å®šä¹‰å¦‚ä¸‹ï¼š

```ts
class C {
// member declarations go here
}
```

å…¶ä¸­ç±»çš„æˆå‘˜ï¼ˆå­—æ®µã€æ–¹æ³•å’Œå‡½æ•°ï¼‰åœ¨èŠ±æ‹¬å·å†…å®šä¹‰ï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰ã€‚


### æ¡ˆä¾‹

```ts
function max(a: int, b: int): int
{
    if a > b then a else b
}

function min(a: int, b: int): int
{
    if a < b then a else b
}

method Max(x: int, y: int) returns (m: int)
requires true;
// ensures (m==x||m==y)&&x<=m&&y<=m
ensures m == max(x,y);
{
    assert true;
    if x <= y
    {
        m:=y;
    }
    else
    {
        m:=x;
    }
}

method Min(x: int, y: int) returns (m: int)
requires true;
// ensures (m==x||m==y)&&x>=m&&y>=m
ensures m == min(x,y)
{
    if(x<=y)
    {
        m:=x;
    }
    else
    {
        m:=y;
    }
}
```

```ts
function pow2(n:nat):nat
{
    if n == 0 then 1
    else 2*pow2(n-1)
}

function pow2v2(a:int,n:nat):int
{
    if n == 0 then 1
    else a*pow2v2(a,n-1)
}
```

```ts
method Pow(a:int,n:nat) returns (result:int)
ensures result == pow2v2(a,n)
{
    result :=1;
    var i:=0;
    while i < n
    invariant 0 <= i <=n
    invariant result == pow2v2(a,(i))
    {
        result := result*a;
        i:=i+1;
    }
}
```

```ts
method SumFirst(n:nat) returns (sum:nat)
ensures sum == n*(n+1)/2
{
    var i:=0;
    sum :=0;
    while(i<n)
    invariant i<=n
    invariant sum == i*(i+1)/2
    {
        i := i + 1;
        sum := sum + i;
    }
}
```

```ts
function Fib(n:nat):nat
{
    if (n < 2) then n 
    else Fib(n-1) + Fib(n-2)
}

method FibIter(n:nat) returns (x:nat)
ensures x == Fib(n)
{
    if(n==0){return 0;}
    var i:=1;
    var a:=0;
    x:=1;
    while(i<n)
    invariant 0<i<=n;
    invariant a==Fib(i-1);
    invariant x==Fib(i);
    decreases n-i
    {
        a,x := x,a+x;
        i:=i+1;
    }
}
```

```ts
method Smallest(a: array<int>) returns (minIndex: nat)
requires a.Length > 0
ensures 0 <= minIndex < a.Length
ensures forall i | 0<=i<a.Length::a[minIndex]<=a[i]
{
    minIndex:=0;
    var i:=0;
    while i<a.Length
    invariant 0<=i<=a.Length
    invariant 0<=minIndex<a.Length
    invariant forall j|0<=j<i::a[minIndex]<=a[j]
    {
        if(a[i]<a[minIndex]){
            minIndex := i;
        }
        i:=i+1;
    }
}
```

```ts
class Pointer {
var a: array<int>
method InitArray(size: nat)
modifies this
{
    var b := new int[size];
    a := b;
    }
}
```

```ts
function SumTo(a: array<int>, i: nat): int
reads a
requires 0 <= i <= a.Length
{
    if i == 0 then 0 else SumTo(a, i - 1) + a[i - 1]
}
method CumulativeSum(a: array<int>)
modifies a
ensures forall i|0<=i<a.Length::a[i]==old(SumTo(a,i+1))
{
    var i:=0;
    var sum:=0;
    while(i<a.Length)
    invariant 0<=i<=a.Length
    invariant forall j|i<=j<a.Length::a[j]==old(a[j])
    invariant sum == old(SumTo(a,i))
    invariant forall j|0<=j<i::a[j]==old(SumTo(a,j+1))
    {
        sum := sum + a[i];
        a[i] := sum;
        i := i + 1;
    }
}
```
