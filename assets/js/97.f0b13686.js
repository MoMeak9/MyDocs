(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{674:function(v,_,i){"use strict";i.r(_);var e=i(5),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h4",{attrs:{id:"介绍chrome-浏览器的几个版本"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#介绍chrome-浏览器的几个版本"}},[v._v("#")]),v._v(" "),i("strong",[v._v("介绍chrome 浏览器的几个版本")])]),v._v(" "),i("p",[v._v("1）Chrome 浏览器提供 4 种发布版本，即稳定版(Stable)、测试版(Beta)、开发者版(Dev)和金丝雀版(Canary)。\n虽然 Chrome 这几个版本名称各不相同，但都沿用了相同的版本号，只是更新早晚的区别。就好比 iOS 等系统，Beta 版可以率先更新到 iOS 12 并进行测试，不断改进稳定后，正式版才升级到 12 版本。\nChrome 也是如此，更新最快的 Canary 会领先正式版 1-2 个版本。")]),v._v(" "),i("p",[v._v("2）对于Chrome的历史版本测试\n可以使用Docker Selenium 做分布式自动化测试，部署多个重点关注的版本，进行自动化测试，对比差异。")]),v._v(" "),i("h4",{attrs:{id:"说一下-http-缓存策略-有什么区别-分别解决了什么问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#说一下-http-缓存策略-有什么区别-分别解决了什么问题"}},[v._v("#")]),v._v(" "),i("strong",[v._v("说一下 Http 缓存策略，有什么区别，分别解决了什么问题")])]),v._v(" "),i("p",[v._v("1）浏览器缓存策略")]),v._v(" "),i("p",[v._v("浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使\n用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：\n强制缓存和协商缓存，强缓优先于协商缓存。")]),v._v(" "),i("ul",[i("li",[v._v("强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。")]),v._v(" "),i("li",[v._v("协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified\n通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。")])]),v._v(" "),i("p",[v._v("HTTP缓存都是从"),i("strong",[v._v("第二次")]),v._v("请求开始的：")]),v._v(" "),i("ul",[i("li",[v._v("第一次请求资源时，服务器返回资源，并在"),i("strong",[v._v("response header")]),v._v("中回传资源的缓存策略；")]),v._v(" "),i("li",[v._v("第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：")])]),v._v(" "),i("p",[i("img",{attrs:{src:"https://camo.githubusercontent.com/df822872ee2a8aef44c665f8fffd13c4cc4eb637bd8706ce4899e8eb72d2a431/687474703a2f2f696d672d7374617469632e796964656e6778756574616e672e636f6d2f77786170702f69737375652d696d672f7169642d382e706e67",alt:"img"}})]),v._v(" "),i("p",[i("strong",[v._v("2）强缓存")])]),v._v(" "),i("ul",[i("li",[v._v("强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk")]),v._v(" "),i("li",[v._v("控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）")]),v._v(" "),i("li",[v._v("Cache-control是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。")]),v._v(" "),i("li",[v._v("Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求")]),v._v(" "),i("li",[v._v("Cache-Control的优先级比Expires的优先级高。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。\n如果同时存在则使用Cache-control。")])]),v._v(" "),i("p",[i("strong",[v._v("3）强缓存-expires")])]),v._v(" "),i("ul",[i("li",[v._v("该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。")]),v._v(" "),i("li",[v._v("Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。")]),v._v(" "),i("li",[v._v("由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。")]),v._v(" "),i("li",[v._v("优势特点\n"),i("ul",[i("li",[v._v("1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。")]),v._v(" "),i("li",[v._v("2、以时刻标识失效时间。")])])]),v._v(" "),i("li",[v._v("劣势问题\n"),i("ul",[i("li",[v._v("1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。")]),v._v(" "),i("li",[v._v("2、存在版本问题，到期之前的修改客户端是不可知的。")])])])]),v._v(" "),i("p",[i("strong",[v._v("4）强缓存-cache-control")])]),v._v(" "),i("ul",[i("li",[i("p",[v._v("已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。")])]),v._v(" "),i("li",[i("p",[v._v("这两者的区别就是前者是绝对时间，而后者是相对时间。下面列举一些 "),i("code",[v._v("Cache-control")]),v._v(" 字段常用的值：(完整的列表可以查看MDN)")]),v._v(" "),i("ul",[i("li",[i("code",[v._v("max-age")]),v._v("：即最大有效时间。")]),v._v(" "),i("li",[i("code",[v._v("must-revalidate")]),v._v("：如果超过了 "),i("code",[v._v("max-age")]),v._v(" 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。")]),v._v(" "),i("li",[i("code",[v._v("no-cache")]),v._v("：不使用强缓存，需要与服务器验证缓存是否新鲜。")]),v._v(" "),i("li",[i("code",[v._v("no-store")]),v._v(": 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。")]),v._v(" "),i("li",[i("code",[v._v("public")]),v._v("：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)")]),v._v(" "),i("li",[i("code",[v._v("private")]),v._v("：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。")])])]),v._v(" "),i("li",[i("p",[i("strong",[v._v("Cache-control 的优先级高于 Expires")]),v._v("，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可以设置。")])]),v._v(" "),i("li",[i("p",[v._v("该字段可以在请求头或者响应头设置，可组合使用多种指令：")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("可缓存性")]),v._v(" "),i("p",[v._v("：")]),v._v(" "),i("ul",[i("li",[v._v("public：浏览器和缓存服务器都可以缓存页面信息")]),v._v(" "),i("li",[v._v("private：default，代理服务器不可缓存，只能被单个用户缓存")]),v._v(" "),i("li",[v._v("no-cache：浏览器器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合private，\n过期时间设置为过去时间。")]),v._v(" "),i("li",[v._v("only-if-cache：客户端只接受已缓存的响应")])])]),v._v(" "),i("li",[i("p",[v._v("到期")]),v._v(" "),i("ul",[i("li",[v._v("max-age=：缓存存储的最大周期，超过这个周期被认为过期。")]),v._v(" "),i("li",[v._v("s-maxage=：设置共享缓存，比如can。会覆盖max-age和expires。")]),v._v(" "),i("li",[v._v("max-stale[=]：客户端愿意接收一个已经过期的资源")]),v._v(" "),i("li",[v._v("min-fresh=：客户端希望在指定的时间内获取最新的响应")]),v._v(" "),i("li",[v._v("stale-while-revalidate=：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应\n的时间长度。")]),v._v(" "),i("li",[v._v("stale-if-error=：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。")])])]),v._v(" "),i("li",[i("p",[v._v("重新验证和重新加载")]),v._v(" "),i("ul",[i("li",[v._v("must-revalidate：如页面过期，则去服务器进行获取。")]),v._v(" "),i("li",[v._v("proxy-revalidate：用于共享缓存。")]),v._v(" "),i("li",[v._v("immutable：响应正文不随时间改变。")])])]),v._v(" "),i("li",[i("p",[v._v("其他")]),v._v(" "),i("ul",[i("li",[v._v("no-store：绝对禁止缓存")]),v._v(" "),i("li",[v._v("no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。")])])])])]),v._v(" "),i("li",[i("p",[v._v("优势特点")]),v._v(" "),i("ul",[i("li",[v._v("1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。")]),v._v(" "),i("li",[v._v("2、比Expires多了很多选项设置。")])])]),v._v(" "),i("li",[i("p",[v._v("劣势问题")]),v._v(" "),i("ul",[i("li",[v._v("1、存在版本问题，到期之前的修改客户端是不可知的。")])])])]),v._v(" "),i("p",[i("strong",[v._v("5）协商缓存")])]),v._v(" "),i("ul",[i("li",[v._v("协商缓存的状态码由服务器决策返回200或者304")]),v._v(" "),i("li",[v._v("当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。")]),v._v(" "),i("li",[v._v("对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。")]),v._v(" "),i("li",[v._v("协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）")]),v._v(" "),i("li",[v._v("Last-Modified/If-Modified-since表示的是服务器的资源最后一次修改的时间；Etag/If-None-match表示的是服务器资源的唯一标\n识，只要资源变化，Etag就会重新生成。")]),v._v(" "),i("li",[v._v("Etag/If-None-match的优先级比Last-Modified/If-Modified-since高。")])]),v._v(" "),i("p",[i("strong",[v._v("6）协商缓存-协商缓存-Last-Modified/If-Modified-since")])]),v._v(" "),i("ul",[i("li",[v._v("1.服务器通过 "),i("code",[v._v("Last-Modified")]),v._v(" 字段告知客户端，资源最后一次被修改的时间，例如 "),i("code",[v._v("Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT")])]),v._v(" "),i("li",[v._v("2.浏览器将这个值和内容一起记录在缓存数据库中。")]),v._v(" "),i("li",[v._v("3.下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 "),i("code",[v._v("Last-Modified")]),v._v(" 的值写入到请求头的 "),i("code",[v._v("If-Modified-Since")]),v._v(" 字段")]),v._v(" "),i("li",[v._v("4.服务器会将 "),i("code",[v._v("If-Modified-Since")]),v._v(" 的值与 "),i("code",[v._v("Last-Modified")]),v._v(" 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。")]),v._v(" "),i("li",[v._v("优势特点\n"),i("ul",[i("li",[v._v("1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。")])])]),v._v(" "),i("li",[v._v("劣势问题\n"),i("ul",[i("li",[v._v("2、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。")]),v._v(" "),i("li",[v._v("3、以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。")]),v._v(" "),i("li",[v._v("4、某些服务器不能精确的得到文件的最后修改时间。")]),v._v(" "),i("li",[v._v("5、如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。")])])])]),v._v(" "),i("p",[i("strong",[v._v("7）协商缓存-Etag/If-None-match")])]),v._v(" "),i("ul",[i("li",[v._v("为了解决上述问题，出现了一组新的字段 "),i("code",[v._v("Etag")]),v._v(" 和 "),i("code",[v._v("If-None-Match")])]),v._v(" "),i("li",[i("code",[v._v("Etag")]),v._v(" 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 "),i("code",[v._v("Etag")]),v._v(" 字段。之后的流程和 "),i("code",[v._v("Last-Modified")]),v._v(" 一致，只是 "),i("code",[v._v("Last-Modified")]),v._v(" 字段和它所表示的更新时间改变成了 "),i("code",[v._v("Etag")]),v._v(" 字段和它所表示的文件 hash，把 "),i("code",[v._v("If-Modified-Since")]),v._v(" 变成了 "),i("code",[v._v("If-None-Match")]),v._v("。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。")]),v._v(" "),i("li",[v._v("浏览器在发起请求时，服务器返回在Response header中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的Etag值赋值给If-No-Matched并添加在Request Header中。服务器将浏览器传来的if-no-matched跟自己的本地的资源的ETag做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。")]),v._v(" "),i("li",[i("strong",[v._v("Etag 的优先级高于 Last-Modified")]),v._v("。")]),v._v(" "),i("li",[v._v("优势特点\n"),i("ul",[i("li",[v._v("1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。")]),v._v(" "),i("li",[v._v("2、不存在版本问题，每次请求都回去服务器进行校验。")])])]),v._v(" "),i("li",[v._v("劣势问题\n"),i("ul",[i("li",[v._v("1、计算ETag值需要性能损耗。")]),v._v(" "),i("li",[v._v("2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现ETag不匹配的情况。")])])])]),v._v(" "),i("h4",{attrs:{id:"前端安全、中间人攻击"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#前端安全、中间人攻击"}},[v._v("#")]),v._v(" 前端安全、中间人攻击")]),v._v(" "),i("p",[i("strong",[v._v("1）XSS：跨站脚本攻击")])]),v._v(" "),i("p",[v._v("就是攻击者想尽一切办法将可以执行的代码注入到网页中。")]),v._v(" "),i("h5",{attrs:{id:"存储型-server端"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#存储型-server端"}},[v._v("#")]),v._v(" 存储型（server端）：")]),v._v(" "),i("ul",[i("li",[v._v("场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。")]),v._v(" "),i("li",[v._v("攻击步骤：\n"),i("ul",[i("li",[v._v("i）攻击者将恶意代码提交到目标网站的数据库中")]),v._v(" "),i("li",[v._v("ii）用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器")]),v._v(" "),i("li",[v._v("iii）用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行")]),v._v(" "),i("li",[v._v("iv）恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作")])])])]),v._v(" "),i("h5",{attrs:{id:"反射型-server端"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#反射型-server端"}},[v._v("#")]),v._v(" 反射型（Server端）")]),v._v(" "),i("p",[v._v("与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在URL上")]),v._v(" "),i("ul",[i("li",[v._v("场景：通过 URL 传递参数的功能，如网站搜索、跳转等。")]),v._v(" "),i("li",[v._v("攻击步骤：\n"),i("ul",[i("li",[v._v("i）攻击者构造出特殊的 URL，其中包含恶意代码。")]),v._v(" "),i("li",[v._v("ii）用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。")]),v._v(" "),i("li",[v._v("iii）用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。")]),v._v(" "),i("li",[v._v("iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。")])])])]),v._v(" "),i("h5",{attrs:{id:"dom-型-浏览器端"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dom-型-浏览器端"}},[v._v("#")]),v._v(" Dom 型(浏览器端）")]),v._v(" "),i("p",[v._v("DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。")]),v._v(" "),i("ul",[i("li",[v._v("场景：通过 URL 传递参数的功能，如网站搜索、跳转等。")]),v._v(" "),i("li",[v._v("攻击步骤：\n"),i("ul",[i("li",[v._v("i）攻击者构造出特殊的 URL，其中包含恶意代码。")]),v._v(" "),i("li",[v._v("ii）用户打开带有恶意代码的 URL。")]),v._v(" "),i("li",[v._v("iii）用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。")]),v._v(" "),i("li",[v._v("iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。")])])])]),v._v(" "),i("h5",{attrs:{id:"预防方案-防止攻击者提交恶意代码-防止浏览器执行恶意代码"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#预防方案-防止攻击者提交恶意代码-防止浏览器执行恶意代码"}},[v._v("#")]),v._v(" 预防方案：（防止攻击者提交恶意代码，防止浏览器执行恶意代码）")]),v._v(" "),i("ul",[i("li",[v._v("i）对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等\n"),i("ul",[i("li",[v._v("避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML")])])]),v._v(" "),i("li",[v._v("ii）CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection\n"),i("ul",[i("li",[v._v("增加攻击难度，配置CSP(本质是建立白名单，由浏览器进行拦截)")]),v._v(" "),i("li",[i("code",[v._v("Content-Security-Policy: default-src 'self'")]),v._v("-所有内容均来自站点的同一个源（不包括其子域名）")]),v._v(" "),i("li",[i("code",[v._v("Content-Security-Policy: default-src 'self' *.trusted.com")]),v._v("-允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)")]),v._v(" "),i("li",[i("code",[v._v("Content-Security-Policy: default-src https://yideng.com")]),v._v("-该服务器仅允许通过HTTPS方式并仅从yideng.com域名来访问文档")])])]),v._v(" "),i("li",[v._v("iii）输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断")]),v._v(" "),i("li",[v._v("iv）开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。")]),v._v(" "),i("li",[v._v("v）验证码")])]),v._v(" "),i("h4",{attrs:{id:"_2-csrf-跨站请求伪造"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-csrf-跨站请求伪造"}},[v._v("#")]),v._v(" 2）CSRF：跨站请求伪造")]),v._v(" "),i("p",[v._v("攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。")]),v._v(" "),i("h5",{attrs:{id:"攻击流程举例"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#攻击流程举例"}},[v._v("#")]),v._v(" 攻击流程举例")]),v._v(" "),i("ul",[i("li",[v._v("i）受害者登录 a.com，并保留了登录凭证（Cookie）")]),v._v(" "),i("li",[v._v("ii）攻击者引诱受害者访问了b.com")]),v._v(" "),i("li",[v._v("iii）b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie")]),v._v(" "),i("li",[v._v("iv）a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求")]),v._v(" "),i("li",[v._v("v）a.com以受害者的名义执行了act=xx")]),v._v(" "),i("li",[v._v("vi）攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作")])]),v._v(" "),i("h5",{attrs:{id:"攻击类型"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#攻击类型"}},[v._v("#")]),v._v(" 攻击类型")]),v._v(" "),i("ul",[i("li",[v._v("i）GET型：如在页面的某个 img 中发起一个 get 请求")]),v._v(" "),i("li",[v._v("ii）POST型：通过自动提交表单到恶意网站")]),v._v(" "),i("li",[v._v("iii）链接型：需要诱导用户点击链接")])]),v._v(" "),i("h5",{attrs:{id:"预防方案"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#预防方案"}},[v._v("#")]),v._v(" 预防方案：")]),v._v(" "),i("p",[v._v("CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。）")]),v._v(" "),i("ul",[i("li",[v._v("i）同源检测：通过Header中的Origin Header 、Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证")]),v._v(" "),i("li",[v._v("ii）CSRF Token 校验：将CSRF Token输出到页面中（通常保存在Session中），页面提交的请求携带这个Token，服务器验证Token是否\n正确")]),v._v(" "),i("li",[v._v("iii）双重cookie验证：\n"),i("ul",[i("li",[v._v("流程：\n"),i("ul",[i("li",[v._v("步骤1：在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）")]),v._v(" "),i("li",[v._v("步骤2：在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）")]),v._v(" "),i("li",[v._v("步骤3：后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。")])])]),v._v(" "),i("li",[v._v("优点：\n"),i("ul",[i("li",[v._v("无需使用Session，适用面更广，易于实施。")]),v._v(" "),i("li",[v._v("Token储存于客户端中，不会给服务器带来压力。")]),v._v(" "),i("li",[v._v("相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。")])])]),v._v(" "),i("li",[v._v("缺点：\n-Cookie中增加了额外的字段。\n-如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。\n-难以做到子域名的隔离。\n-为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。")])])]),v._v(" "),i("li",[v._v("iv）Samesite Cookie属性：Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，Strict 为任何情况下都不可以作为第三方 Cookie ，Lax 为可以作为第三方 Cookie , 但必须是Get请求")])]),v._v(" "),i("p",[i("strong",[v._v("3）iframe 安全")])]),v._v(" "),i("h5",{attrs:{id:"说明"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[v._v("#")]),v._v(" 说明：")]),v._v(" "),i("ul",[i("li",[v._v("i）嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题")]),v._v(" "),i("li",[v._v("ii）点击劫持\n"),i("ul",[i("li",[v._v("攻击者将目标网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，诱导用户点击。")])])]),v._v(" "),i("li",[v._v("iii）禁止自己的 iframe 中的链接外部网站的JS")])]),v._v(" "),i("h5",{attrs:{id:"预防方案-2"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#预防方案-2"}},[v._v("#")]),v._v(" 预防方案：")]),v._v(" "),i("ul",[i("li",[v._v("i）为 iframe 设置 sandbox 属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则")]),v._v(" "),i("li",[v._v("ii）服务端设置 X-Frame-Options Header头，拒绝页面被嵌套，X-Frame-Options 是HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入 "),i("iframe",[v._v(" 中\n"),i("ul",[i("li",[v._v("eg."),i("code",[v._v("X-Frame-Options: SAMEORIGIN")])]),v._v(" "),i("li",[v._v("SAMEORIGIN: iframe 页面的地址只能为同源域名下的页面")]),v._v(" "),i("li",[v._v("ALLOW-FROM: 可以嵌套在指定来源的 iframe 里")]),v._v(" "),i("li",[v._v("DENY: 当前页面不能被嵌套在 iframe 里")])])])]),v._v(" "),i("li",[v._v("iii）设置 CSP 即 Content-Security-Policy 请求头")]),v._v(" "),i("li",[v._v("iv）减少对 iframe 的使用")])]),v._v(" "),i("p",[i("strong",[v._v("4）错误的内容推断")])]),v._v(" "),i("h5",{attrs:{id:"说明-2"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#说明-2"}},[v._v("#")]),v._v(" 说明：")]),v._v(" "),i("p",[v._v("文件上传类型校验失败后，导致恶意的JS文件上传后，浏览器 Content-Type Header 的默认解析为可执行的 JS 文件")]),v._v(" "),i("h5",{attrs:{id:"预防方案-3"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#预防方案-3"}},[v._v("#")]),v._v(" 预防方案：")]),v._v(" "),i("p",[v._v("设置 X-Content-Type-Options 头")]),v._v(" "),i("p",[i("strong",[v._v("5）第三方依赖包")])]),v._v(" "),i("p",[v._v("减少对第三方依赖包的使用，如之前 npm 的包如：event-stream 被爆出恶意攻击数字货币；")]),v._v(" "),i("p",[i("strong",[v._v("6）HTTPS")])]),v._v(" "),i("h5",{attrs:{id:"描述"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[v._v("#")]),v._v(" 描述：")]),v._v(" "),i("p",[v._v("黑客可以利用"),i("strong",[v._v("SSL Stripping")]),v._v("这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。")]),v._v(" "),i("h5",{attrs:{id:"预防方案-4"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#预防方案-4"}},[v._v("#")]),v._v(" 预防方案：")]),v._v(" "),i("p",[v._v("使用HSTS（HTTP Strict Transport Security），它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信。这里的“强制性”表现为浏览器无论在何种情况下都直接向务器端发起HTTPS请求，而不再像以往那样从HTTP跳转到HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再\n用户选择是否继续进行不安全的通信。")]),v._v(" "),i("p",[i("strong",[v._v("7）本地存储数据")])]),v._v(" "),i("p",[v._v("避免重要的用户信息存在浏览器缓存中")]),v._v(" "),i("p",[i("strong",[v._v("8）静态资源完整性校验")])]),v._v(" "),i("h5",{attrs:{id:"描述-2"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#描述-2"}},[v._v("#")]),v._v(" 描述")]),v._v(" "),i("p",[v._v("使用 内容分发网络 (CDNs) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件），因此可能潜在地攻击所有从该 CDN 获取文件的站点。")]),v._v(" "),i("h5",{attrs:{id:"预防方案-5"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#预防方案-5"}},[v._v("#")]),v._v(" 预防方案")]),v._v(" "),i("p",[v._v("将使用 base64 编码过后的文件哈希值写入你所引用的 "),i("script")])])}),[],!1,null,null,null);_.default=t.exports}}]);