(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{713:function(t,a,r){"use strict";r.r(a);var e=r(5),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"network-layer-网络层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#network-layer-网络层"}},[t._v("#")]),t._v(" Network layer 网络层")]),t._v(" "),r("h3",{attrs:{id:"路由选择routing-确定哪一条路径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由选择routing-确定哪一条路径"}},[t._v("#")]),t._v(" 路由选择routing（确定哪一条路径）")]),t._v(" "),r("p",[t._v("The routing table is constructed according to the specific routing "),r("strong",[t._v("protocol")]),t._v(", and the routing table is constantly updated and maintained by exchanging routing information with neighboring routers.")]),t._v(" "),r("p",[t._v("路由表是根据特定的路由协议构建的，通过与相邻路由器交换路由信息，不断更新和维护路由表。")]),t._v(" "),r("p",[t._v("According to the complex distributed algorithm, Dynamically change the route selected.")]),t._v(" "),r("p",[t._v("根据复杂的分布式算法，动态改变所选择的路由。")]),t._v(" "),r("h3",{attrs:{id:"分组转发forwarding-当一个分组到达时采取的动作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分组转发forwarding-当一个分组到达时采取的动作"}},[t._v("#")]),t._v(" 分组转发forwarding（当一个分组到达时采取的动作）")]),t._v(" "),r("p",[t._v("To deal with the data flow through the router, the key operations are forwarding table query, forwarding and related queue management and task scheduling.")]),t._v(" "),r("p",[t._v("The router forwards the user's IP datagrams from the appropriate port based on the forwarding table.")]),t._v(" "),r("p",[t._v("处理通过路由器的数据流，关键操作是转发表查询、转发以及相关的队列管理和任务调度。")]),t._v(" "),r("p",[t._v("路由器根据转发表将用户的IP数据报从合适的端口转发出去。")]),t._v(" "),r("h2",{attrs:{id:"routing-algorithm-路由算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#routing-algorithm-路由算法"}},[t._v("#")]),t._v(" Routing Algorithm 路由算法")]),t._v(" "),r("h2",{attrs:{id:"static-and-dynamic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#static-and-dynamic"}},[t._v("#")]),t._v(" Static and Dynamic")]),t._v(" "),r("h4",{attrs:{id:"静态算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态算法"}},[t._v("#")]),t._v(" 静态算法：")]),t._v(" "),r("p",[t._v("routes change slowly over  time")]),t._v(" "),r("h4",{attrs:{id:"动态算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态算法"}},[t._v("#")]),t._v(" 动态算法：")]),t._v(" "),r("p",[t._v("routes change more  quickly，Improves performance and flow control性能增强并有利于流量控制")]),t._v(" "),r("h3",{attrs:{id:"routing-protocols-路由协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#routing-protocols-路由协议"}},[t._v("#")]),t._v(" Routing protocols 路由协议")]),t._v(" "),r("p",[t._v("目的：determine “good” paths  (equivalently, routes), from sending hosts to  receiving host, through network of routers.")]),t._v(" "),r("h4",{attrs:{id:"link-state-链路状态路由算法-dijkstra-s-algorithm-spf"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#link-state-链路状态路由算法-dijkstra-s-algorithm-spf"}},[t._v("#")]),t._v(" ⭐️link state 链路状态路由算法  Dijkstra's Algorithm SPF")]),t._v(" "),r("p",[r("strong",[t._v("c(x,y): 节点x到节点y的链路开销; 如果不是直接邻居=∞")])]),t._v(" "),r("p",[r("strong",[t._v("D(v): 从源到目标的路径开销的当前值")])]),t._v(" "),r("p",[r("strong",[t._v("N': 已知最小代价路径的节点集")])]),t._v(" "),r("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220163456245.png",alt:"image-20211220163456245"}}),t._v(" "),r("h4",{attrs:{id:"bellman-ford-equation-dynamic-programming-贝尔曼-福德-距离向量方程-动态规划-rip"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bellman-ford-equation-dynamic-programming-贝尔曼-福德-距离向量方程-动态规划-rip"}},[t._v("#")]),t._v(" ⭐️Bellman-Ford equation(dynamic programming) （贝尔曼-福德）距离向量方程(动态规划) RIP")]),t._v(" "),r("p",[r("strong",[t._v("重要")])]),t._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211206165221062.png",alt:"image-20211206165221062"}}),t._v(" "),r("h4",{attrs:{id:"distance-vector-距离-向量路由算法-rip"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#distance-vector-距离-向量路由算法-rip"}},[t._v("#")]),t._v(" ⭐️distance vector 距离-向量路由算法 RIP")]),t._v(" "),r("p",[r("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220153752060.png",alt:"image-20211220153752060"}}),r("strong",[t._v("重要！")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220153834655.png",alt:"image-20211220153834655"}})]),t._v(" "),r("p",[t._v("第二布，将无限符号替换为来自其他表的数据，并对自己本身行区域最小值优化，最后的表格则为综合了第二部三个表的最优解的答案（内容完全相同）")]),t._v(" "),r("h4",{attrs:{id:"link-cost-changes-链路消耗变化会发生什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#link-cost-changes-链路消耗变化会发生什么"}},[t._v("#")]),t._v(" ⭐️link cost changes 链路消耗变化会发生什么？")]),t._v(" "),r("p",[r("strong",[t._v("DV(distance vector)")])]),t._v(" "),r("p",[t._v("t0,t1,t2...")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20211220155156549.png",alt:"image-20211220155156549"}})]),t._v(" "),r("p",[t._v("在变成静态之前算法迭代两次")]),t._v(" "),r("p",[t._v("t0: y检测到链路开销的变化，更新DV，通知邻居。")]),t._v(" "),r("p",[t._v("t1: z收到y的更新，更新它的表，计算x的新最小成本，给它的邻居发送DV。")]),t._v(" "),r("p",[t._v("t2: y收到z的更新，更新它的距离表。Y的最小代价不变，所以Y不会向z发送消息。自动终止")])])}),[],!1,null,null,null);a.default=s.exports}}]);