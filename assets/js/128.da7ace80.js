(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{703:function(t,a,e){"use strict";e.r(a);var i=e(5),s=Object(i.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"l18-minimum-spanning-tree-mst"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#l18-minimum-spanning-tree-mst"}},[t._v("#")]),t._v(" L18 Minimum Spanning Tree MST")]),t._v(" "),e("p",[e("strong",[t._v("！各类算法的时间复杂度及其推导")])]),t._v(" "),e("p",[t._v("最小生成树有(V - 1)条边，其中V是给定图中的顶点数。")]),t._v(" "),e("h3",{attrs:{id:"kruskal-s-algorithm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kruskal-s-algorithm"}},[t._v("#")]),t._v(" Kruskal’s algorithm")]),t._v(" "),e("p",[e("strong",[t._v("STEP:")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("对所有边按其权值的非递减顺序排序。"),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"images/image-20210706153401937.png",alt:"image-20210706153401937"}})])]),t._v(" "),e("li",[e("p",[t._v("选择最小的边。检查到目前为止生成树是否形成了一个循环。如果没有形成循环，包括这条边。丢弃它。")])]),t._v(" "),e("li",[e("p",[t._v("重复步骤#2，直到生成树中有(V-1)边。")])])]),t._v(" "),e("h4",{attrs:{id:"time-complexity-时间复杂度推导"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#time-complexity-时间复杂度推导"}},[t._v("#")]),t._v(" Time Complexity 时间复杂度推导")]),t._v(" "),e("p",[e("strong",[t._v("O(|E|log |E|) or O(|E| log|V|).")])]),t._v(" "),e("ol",[e("li",[t._v("边的排序需要O(|E| log |E|)的时间。")]),t._v(" "),e("li",[t._v("排序完成后，遍历所有边，应用查找并集算法。")]),t._v(" "),e("li",[t._v("查找和并集操"),e("strong",[t._v("Union-Find algorithm")]),t._v("作最多花费O(|E|log |V|)时间。")]),t._v(" "),e("li",[t._v("所以总的复杂度是**O(|E|log|E| + |E|log|V|)**时间。")]),t._v(" "),e("li",[e("strong",[t._v("（化简，log中2次方提前，消除）")]),t._v("|E|的取值最多为O(|V|2)，"),e("strong",[t._v("所以O(log|V|)等于O(log|E|)")])])]),t._v(" "),e("p",[e("strong",[t._v("因此，总的时间复杂度是O(|E|log| E|)或O(|E|log|V|)")])]),t._v(" "),e("h4",{attrs:{id:"union-find-data-structure-并查集-联合查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#union-find-data-structure-并查集-联合查找"}},[t._v("#")]),t._v(" "),e("strong",[t._v("Union–find data structure")]),t._v(" 并查集-联合查找")]),t._v(" "),e("p",[t._v("如果在构图时找出相同的父亲节点，则有循环cycle，不连接")]),t._v(" "),e("p",[e("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/image-20210706160657082.png",alt:"image-20210706160657082"}}),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/image-20210706160723864.png",alt:"image-20210706160723864"}}),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/image-20210706160738767.png",alt:"image-20210706160738767"}}),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/image-20210706160831309.png",alt:"image-20210706160831309"}})]),t._v(" "),e("h3",{attrs:{id:"prim-s-algorithm-普里姆算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prim-s-algorithm-普里姆算法"}},[t._v("#")]),t._v(" Prim’s algorithm 普里姆算法")]),t._v(" "),e("h4",{attrs:{id:"matrix-representation-矩阵法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#matrix-representation-矩阵法"}},[t._v("#")]),t._v(" "),e("strong",[t._v("matrix representation")]),t._v(" 矩阵法")]),t._v(" "),e("p",[t._v("我们使用一个布尔数组mstSet[]来表示MST中包含的顶点集。{"),e("strong",[t._v("0")]),t._v(", INF, INF, INF, INF, INF, INF, INF} ，0作为起始点。使用完将其记录")]),t._v(" "),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"images/image-20210706155921830.png",alt:"image-20210706155921830"}}),t._v(" "),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"images/image-20210706160010211.png",alt:"image-20210706160010211"}}),t._v(" "),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"images/image-20210706160017052.png",alt:"image-20210706160017052"}}),t._v(" "),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"images/image-20210706160305120.png",alt:"image-20210706160305120"}}),t._v(" "),e("p",[e("strong",[t._v("时间复杂度"),e("img",{attrs:{src:"https://wikimedia.org/api/rest_v1/media/math/render/svg/e1e99764e23be92b694aef042c6460ff921357e3",alt:"O(|V|^{2})"}})])]),t._v(" "),e("h4",{attrs:{id:"adjacency-list-representation-邻接表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#adjacency-list-representation-邻接表"}},[t._v("#")]),t._v(" "),e("strong",[t._v("adjacency list representation 邻接表")])]),t._v(" "),e("p",[t._v("Worst case time complexity of Prim’s Algorithm is\n"),e("strong",[t._v("O(|E| log |V|) using binary heap 二进制堆")])]),t._v(" "),e("p",[e("strong",[t._v("推理：")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("如果用邻接表表示图，则使用广度优先搜索，可以在O(|V| + |E|)的时间内遍历所有顶点。•If adjacency list is used to represent the graph, then using breadth first search, all the vertices can be traversed in O(|V| + |E|) time.")])]),t._v(" "),e("li",[e("p",[t._v("最小堆操作，如提取最小元素和减少键值需要O(log |V|)的时间。Min heap operations like extracting minimum element and decreasing key value takes O(log |V|) time.")])]),t._v(" "),e("li",[e("p",[t._v("So, overall time complexity is "),e("strong",[t._v("O(|E| + |V|) x O(log |V|) = O((|E| + |V|) log |V|) = O(|E| log |V|)")])])])]),t._v(" "),e("p",[e("strong",[t._v("O(|E| + |V| log |V|) using Fibonacci heap 斐波那契堆（优化结果）")])])])}),[],!1,null,null,null);a.default=s.exports}}]);