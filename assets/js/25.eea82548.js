(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{602:function(t,e,a){"use strict";a.r(e);var n=a(5),l=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"call-apply-bind的核心理念-借用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind的核心理念-借用方法"}},[t._v("#")]),t._v(" call/apply/bind的核心理念：借用方法")]),t._v(" "),a("p",[t._v("看到一个非常棒的例子：")]),t._v(" "),a("p",[t._v("生活中：")]),t._v(" "),a("p",[t._v("平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。")]),t._v(" "),a("p",[t._v("程序中：")]),t._v(" "),a("p",[t._v("A对象有个方法，B对象因为某种原因也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？")]),t._v(" "),a("p",[t._v("当然是借用 A 对象的方法啦，既达到了目的，又节省了内存。")]),t._v(" "),a("p",[a("strong",[t._v("这就是call/apply/bind的核心理念：借用方法")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("借助已实现的方法，改变方法中数据的this指向，减少重复代码，节省内存。")])]),t._v(" "),a("h2",{attrs:{id:"call-apply-bind的基本介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind的基本介绍"}},[t._v("#")]),t._v(" call,apply,bind的基本介绍")]),t._v(" "),a("h4",{attrs:{id:"语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fun.call(thisArg, param1, param2, ...)\nfun.apply(thisArg, [param1,param2,...])\nfun.bind(thisArg, param1, param2, ...)\n")])])]),a("h4",{attrs:{id:"返回值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#返回值"}},[t._v("#")]),t._v(" 返回值：")]),t._v(" "),a("p",[t._v("call/apply："),a("code",[t._v("fun")]),t._v("执行的结果 bind：返回"),a("code",[t._v("fun")]),t._v("的拷贝，并拥有指定的"),a("code",[t._v("this")]),t._v("值和初始参数")]),t._v(" "),a("h4",{attrs:{id:"参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[t._v("#")]),t._v(" 参数")]),t._v(" "),a("p",[a("code",[t._v("thisArg")]),t._v("(可选):")]),t._v(" "),a("ol",[a("li",[a("strong",[a("code",[t._v("fun")]),t._v("的"),a("code",[t._v("this")]),t._v("指向"),a("code",[t._v("thisArg")]),t._v("对象")])]),t._v(" "),a("li",[t._v("非严格模式下：thisArg指定为null，undefined，fun中的this指向window对象.")]),t._v(" "),a("li",[t._v("严格模式下："),a("code",[t._v("fun")]),t._v("的"),a("code",[t._v("this")]),t._v("为"),a("code",[t._v("undefined")])]),t._v(" "),a("li",[t._v("值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean")])]),t._v(" "),a("p",[a("code",[t._v("param1,param2")]),t._v("(可选): 传给"),a("code",[t._v("fun")]),t._v("的参数。")]),t._v(" "),a("ol",[a("li",[t._v("如果param不传或为 null/undefined，则表示不需要传入任何参数.")]),t._v(" "),a("li",[t._v("apply第二个参数为数组，数组内的值为传给"),a("code",[t._v("fun")]),t._v("的参数。")])]),t._v(" "),a("h3",{attrs:{id:"调用call-apply-bind的必须是个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用call-apply-bind的必须是个函数"}},[t._v("#")]),t._v(" 调用"),a("code",[t._v("call")]),t._v("/"),a("code",[t._v("apply")]),t._v("/"),a("code",[t._v("bind")]),t._v("的必须是个函数")]),t._v(" "),a("p",[t._v("call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。")]),t._v(" "),a("p",[t._v("只要是函数就可以，比如: "),a("code",[t._v("Object.prototype.toString")]),t._v("就是个函数，我们经常看到这样的用法："),a("code",[t._v("Object.prototype.toString.call(data)")])]),t._v(" "),a("h3",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用：")]),t._v(" "),a("p",[t._v("改变函数执行时的this指向，目前所有关于它们的运用，都是基于这一点来进行的。")]),t._v(" "),a("h3",{attrs:{id:"如何不弄混call和apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何不弄混call和apply"}},[t._v("#")]),t._v(" 如何不弄混call和apply")]),t._v(" "),a("blockquote",[a("p",[t._v("弄混这两个API的不在少数，不要小看这个问题，记住下面的这个方法就好了。")])]),t._v(" "),a("p",[a("code",[t._v("apply")]),t._v("是以"),a("code",[t._v("a")]),t._v("开头，它传给"),a("code",[t._v("fun")]),t._v("的参数是"),a("code",[t._v("Array")]),t._v("，也是以"),a("code",[t._v("a")]),t._v("开头的。")]),t._v(" "),a("h3",{attrs:{id:"区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别：")]),t._v(" "),a("h4",{attrs:{id:"call与apply的唯一区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call与apply的唯一区别"}},[t._v("#")]),t._v(" call与apply的唯一区别")]),t._v(" "),a("p",[t._v("传给"),a("code",[t._v("fun")]),t._v("的参数写法不同：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("apply")]),t._v("是第2个参数，这个参数是一个数组：传给"),a("code",[t._v("fun")]),t._v("参数都写在数组中。")]),t._v(" "),a("li",[a("code",[t._v("call")]),t._v("从第2~n的参数都是传给"),a("code",[t._v("fun")]),t._v("的。")])]),t._v(" "),a("h4",{attrs:{id:"call-apply与bind的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-apply与bind的区别"}},[t._v("#")]),t._v(" call/apply与bind的区别")]),t._v(" "),a("p",[a("strong",[t._v("执行")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("call/apply改变了函数的this上下文后马上"),a("strong",[t._v("执行该函数")])]),t._v(" "),a("li",[t._v("bind则是返回改变了上下文后的函数,"),a("strong",[t._v("不执行该函数")])])]),t._v(" "),a("p",[a("strong",[t._v("返回值")]),t._v(":")]),t._v(" "),a("ul",[a("li",[t._v("call/apply 返回"),a("code",[t._v("fun")]),t._v("的执行结果")]),t._v(" "),a("li",[t._v("bind返回fun的拷贝，并指定了fun的this指向，保存了fun的参数。")])]),t._v(" "),a("p",[t._v("返回值这段在下方bind应用中有详细的示例解析。")]),t._v(" "),a("h2",{attrs:{id:"call和apply的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call和apply的应用场景"}},[t._v("#")]),t._v(" call和apply的应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("这些应用场景，多加体会就可以发现它们的理念都是：借用方法")])]),t._v(" "),a("ol",[a("li",[t._v("判断数据类型：")])]),t._v(" "),a("p",[a("code",[t._v("Object.prototype.toString")]),t._v("用来判断类型再合适不过，借用它我们几乎可以判断所有类型的数据：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function isType(data, type) {\n    const typeObj = {\n        '[object String]': 'string',\n        '[object Number]': 'number',\n        '[object Boolean]': 'boolean',\n        '[object Null]': 'null',\n        '[object Undefined]': 'undefined',\n        '[object Object]': 'object',\n        '[object Array]': 'array',\n        '[object Function]': 'function',\n        '[object Date]': 'date', // Object.prototype.toString.call(new Date())\n        '[object RegExp]': 'regExp',\n        '[object Map]': 'map',\n        '[object Set]': 'set',\n        '[object HTMLDivElement]': 'dom', // document.querySelector('#app')\n        '[object WeakMap]': 'weakMap',\n        '[object Window]': 'window',  // Object.prototype.toString.call(window)\n        '[object Error]': 'error', // new Error('1')\n        '[object Arguments]': 'arguments',\n    }\n    let name = Object.prototype.toString.call(data) // 借用Object.prototype.toString()获取数据类型\n    let typeName = typeObj[name] || '未知类型' // 匹配数据类型\n    return typeName === type // 判断该数据类型是否为传入的类型\n}\nconsole.log(\n    isType({}, 'object'), // true\n    isType([], 'array'), // true\n    isType(new Date(), 'object'), // false\n    isType(new Date(), 'date'), // true\n)\n")])])]),a("ol",[a("li",[t._v("类数组借用数组的方法：")])]),t._v(" "),a("p",[t._v("类数组因为不是真正的数组所有没有数组类型上自带的种种方法，所以我们需要去借用数组的方法。")]),t._v(" "),a("p",[t._v("比如借用数组的push方法：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('var arrayLike = {\n  0: \'OB\',\n  1: \'Koro1\',\n  length: 2\n}\nArray.prototype.push.call(arrayLike, \'添加元素1\', \'添加元素2\');\nconsole.log(arrayLike) // {"0":"OB","1":"Koro1","2":"添加元素1","3":"添加元素2","length":4}\n')])])]),a("ol",[a("li",[t._v("apply获取数组最大值最小值：")])]),t._v(" "),a("p",[t._v("apply直接传递数组做要调用方法的参数，也省一步展开数组，比如使用"),a("code",[t._v("Math.max")]),t._v("、"),a("code",[t._v("Math.min")]),t._v("来获取数组的最大值/最小值:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const arr = [15, 6, 12, 13, 16];\nconst max = Math.max.apply(Math, arr); // 16\nconst min = Math.min.apply(Math, arr); // 6\n")])])]),a("ol",[a("li",[t._v("继承")])]),t._v(" "),a("p",[t._v("ES5的继承也都是通过借用父类的构造方法来实现父类方法/属性的继承：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// 父类\nfunction supFather(name) {\n    this.name = name;\n    this.colors = [\'red\', \'blue\', \'green\']; // 复杂类型\n}\nsupFather.prototype.sayName = function (age) {\n    console.log(this.name, \'age\');\n};\n// 子类\nfunction sub(name, age) {\n    // 借用父类的方法：修改它的this指向,赋值父类的构造函数里面方法、属性到子类上\n    supFather.call(this, name);\n    this.age = age;\n}\n// 重写子类的prototype，修正constructor指向\nfunction inheritPrototype(sonFn, fatherFn) {\n    sonFn.prototype = Object.create(fatherFn.prototype); // 继承父类的属性以及方法\n    sonFn.prototype.constructor = sonFn; // 修正constructor指向到继承的那个函数上\n}\ninheritPrototype(sub, supFather);\nsub.prototype.sayAge = function () {\n    console.log(this.age, \'foo\');\n};\n// 实例化子类，可以在实例上找到属性、方法\nconst instance1 = new sub("OBKoro1", 24);\nconst instance2 = new sub("小明", 18);\ninstance1.colors.push(\'black\')\nconsole.log(instance1) // {"name":"OBKoro1","colors":["red","blue","green","black"],"age":24}\nconsole.log(instance2) // {"name":"小明","colors":["red","blue","green"],"age":18} \n')])])]),a("p",[t._v("类似的应用场景还有很多，就不赘述了，关键在于它们借用方法的理念，不理解的话多看几遍。")]),t._v(" "),a("h2",{attrs:{id:"call、apply-该用哪个-、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call、apply-该用哪个-、"}},[t._v("#")]),t._v(" call、apply，该用哪个？、")]),t._v(" "),a("p",[t._v("call,apply的效果完全一样，它们的区别也在于")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("参数数量/顺序确定就用call，参数数量/顺序不确定的话就用apply")]),t._v("。")]),t._v(" "),a("li",[t._v("考虑可读性：参数数量不多就用call，参数数量比较多的话，把参数整合成数组，使用apply。")]),t._v(" "),a("li",[t._v("参数集合已经是一个数组的情况，用apply，比如上文的获取数组最大值/最小值。")])]),t._v(" "),a("p",[t._v("参数数量/顺序不确定的话就用apply，比如以下示例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const obj = {\n    age: 24,\n    name: 'OBKoro1',\n}\nconst obj2 = {\n    age: 777\n}\ncallObj(obj, handle)\ncallObj(obj2, handle)\n// 根据某些条件来决定要传递参数的数量、以及顺序\nfunction callObj(thisAge, fn) {\n    let params = []\n    if (thisAge.name) {\n        params.push(thisAge.name)\n    }\n    if (thisAge.age) {\n        params.push(thisAge.age)\n    }\n    fn.apply(thisAge, params) // 数量和顺序不确定 不能使用call\n}\nfunction handle(...params) {\n    console.log('params', params) // do some thing\n}\n")])])]),a("h2",{attrs:{id:"bind的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind的应用场景"}},[t._v("#")]),t._v(" bind的应用场景：")]),t._v(" "),a("h4",{attrs:{id:"_1-保存函数参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-保存函数参数"}},[t._v("#")]),t._v(" 1. 保存函数参数：")]),t._v(" "),a("p",[t._v("首先来看下一道经典的面试题：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for (var i = 1; i <= 5; i++) {\n   setTimeout(function test() {\n        console.log(i) // 依次输出：6 6 6 6 6\n    }, i * 1000);\n}\n复制代码\n")])])]),a("p",[t._v("造成这个现象的原因是等到"),a("code",[t._v("setTimeout")]),t._v("异步执行时,"),a("code",[t._v("i")]),t._v("已经变成6了。")]),t._v(" "),a("p",[t._v("关于js事件循环机制不理解的同学，可以看我这篇博客："),a("a",{attrs:{href:"https://juejin.cn/post/6844903621872582669",target:"_blank",rel:"noopener noreferrer"}},[t._v("Js 的事件循环(Event Loop)机制以及实例讲解"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("那么如何使他输出: 1,2,3,4,5呢？")]),t._v(" "),a("p",[t._v("方法有很多：")]),t._v(" "),a("ul",[a("li",[t._v("闭包, 保存变量")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for (var i = 1; i <= 5; i++) {\n    (function (i) {\n        setTimeout(function () {\n            console.log('闭包:', i); // 依次输出：1 2 3 4 5\n        }, i * 1000);\n    }(i));\n}\n复制代码\n")])])]),a("p",[t._v("在这里创建了一个闭包，每次循环都会把"),a("code",[t._v("i")]),t._v("的最新值传进去，然后被闭包保存起来。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("bind")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for (var i = 1; i <= 5; i++) {\n    // 缓存参数\n    setTimeout(function (i) {\n        console.log('bind', i) // 依次输出：1 2 3 4 5\n    }.bind(null, i), i * 1000);\n}\n复制代码\n")])])]),a("p",[a("strong",[t._v("实际上这里也用了闭包，我们知道bind会返回一个函数，这个函数也是闭包")]),t._v("。")]),t._v(" "),a("p",[t._v("它保存了函数的this指向、初始参数，每次"),a("code",[t._v("i")]),t._v("的变更都会被bind的闭包存起来，所以输出1-5。")]),t._v(" "),a("p",[t._v("具体细节，下面有个手写bind方法，研究一下，就能搞懂了。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("let")])])]),t._v(" "),a("p",[t._v("用"),a("code",[t._v("let")]),t._v("声明"),a("code",[t._v("i")]),t._v("也可以输出1-5: 因为"),a("code",[t._v("let")]),t._v("是块级作用域,所以每次都会创建一个新的变量,所以"),a("code",[t._v("setTimeout")]),t._v("每次读的值都是不同的,"),a("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fq%2F1010000007541743",target:"_blank",rel:"noopener noreferrer"}},[t._v("详解"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"中高级面试题-手写call-apply、bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中高级面试题-手写call-apply、bind"}},[t._v("#")]),t._v(" 中高级面试题-手写call/apply、bind：")]),t._v(" "),a("p",[t._v("在大厂的面试中，手写实现call,apply,bind(特别是bind)一直是比较高频的面试题，在这里我们也一起来实现一下这几个函数。")]),t._v(" "),a("h4",{attrs:{id:"你能手写实现一个call吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你能手写实现一个call吗"}},[t._v("#")]),t._v(" 你能手写实现一个"),a("code",[t._v("call")]),t._v("吗？")]),t._v(" "),a("p",[a("strong",[t._v("思路")])]),t._v(" "),a("ol",[a("li",[t._v("根据call的规则设置上下文对象,也就是"),a("code",[t._v("this")]),t._v("的指向。")]),t._v(" "),a("li",[t._v("通过设置"),a("code",[t._v("context")]),t._v("的属性,将函数的this指向"),a("a",{attrs:{href:"https://juejin.cn/post/6844903630592540686#heading-4",target:"_blank",rel:"noopener noreferrer"}},[t._v("隐式绑定"),a("OutboundLink")],1),t._v("到context上")]),t._v(" "),a("li",[t._v("通过隐式绑定执行函数并传递参数。")]),t._v(" "),a("li",[t._v("删除临时属性，返回函数执行结果")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Function.prototype.myCall = function (context, ...arr) {\n    if (context === null || context === undefined) {\n       // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)\n        context = window \n    } else {\n        context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象\n    }\n    const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数\n    context[specialPrototype] = this; // 函数的this指向隐式绑定到context上\n    let result = context[specialPrototype](...arr); // 通过隐式绑定执行函数并传递参数\n    delete context[specialPrototype]; // 删除上下文对象的属性\n    return result; // 返回函数执行结果\n};\n复制代码\n")])])]),a("h4",{attrs:{id:"判断函数的上下文对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断函数的上下文对象"}},[t._v("#")]),t._v(" 判断函数的上下文对象：")]),t._v(" "),a("p",[t._v("很多人判断函数上下文对象，只是简单的以"),a("code",[t._v("context")]),t._v("是否为false来判断,比如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 判断函数上下文绑定到`window`不够严谨\ncontext = context ? Object(context) : window; \ncontext = context || window; \n复制代码\n")])])]),a("p",[t._v("经过测试,以下三种为false的情况,函数的上下文对象都会绑定到"),a("code",[t._v("window")]),t._v("上：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 网上的其他绑定函数上下文对象的方案: context = context || window; \nfunction handle(...params) {\n    this.test = 'handle'\n    console.log('params', this, ...params) // do some thing\n}\nhandle.elseCall('') // window\nhandle.elseCall(0) // window\nhandle.elseCall(false) // window\n复制代码\n")])])]),a("p",[t._v("而"),a("code",[t._v("call")]),t._v("则将函数的上下文对象会绑定到这些原始值的实例对象上：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/4/16c5bdb742a5f2b0~tplv-t2oaga2asx-watermark.awebp",alt:"原始值的实例对象"}})]),t._v(" "),a("p",[t._v("所以正确的解决方案，应该是像我上面那么做：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 正确判断函数上下文对象\n    if (context === null || context === undefined) {\n       // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)\n        context = window \n    } else {\n        context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象\n    }\n复制代码\n")])])]),a("h3",{attrs:{id:"使用symbol临时储存函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用symbol临时储存函数"}},[t._v("#")]),t._v(" 使用"),a("code",[t._v("Symbol")]),t._v("临时储存函数")]),t._v(" "),a("p",[t._v("尽管之前用的属性是"),a("code",[t._v("testFn")]),t._v("但不得不承认，还是有跟上下文对象的原属性冲突的风险,经网友提醒使用"),a("code",[t._v("Symbol")]),t._v("就不会出现冲突了。")]),t._v(" "),a("p",[t._v("考虑兼容的话,还是用尽量特殊的属性，比如带上自己的ID："),a("code",[t._v("OBKoro1TestFn")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"你能手写实现一个apply吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你能手写实现一个apply吗"}},[t._v("#")]),t._v(" 你能手写实现一个"),a("code",[t._v("apply")]),t._v("吗？")]),t._v(" "),a("p",[t._v("思路：")]),t._v(" "),a("ol",[a("li",[t._v("传递给函数的参数处理，不太一样，其他部分跟"),a("code",[t._v("call")]),t._v("一样。")]),t._v(" "),a("li",[a("code",[t._v("apply")]),t._v("接受第二个参数为类数组对象, 这里用了JavaScript权威指南中判断是否为类数组对象的方法。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Function.prototype.myApply = function (context) {\n    if (context === null || context === undefined) {\n        context = window // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)\n    } else {\n        context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象\n    }\n    // JavaScript权威指南判断是否为类数组对象\n    function isArrayLike(o) {\n        if (o &&                                    // o不是null、undefined等\n            typeof o === 'object' &&                // o是对象\n            isFinite(o.length) &&                   // o.length是有限数值\n            o.length >= 0 &&                        // o.length为非负值\n            o.length === Math.floor(o.length) &&    // o.length是整数\n            o.length < 4294967296)                  // o.length < 2^32\n            return true\n        else\n            return false\n    }\n    const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数\n    context[specialPrototype] = this; // 隐式绑定this指向到context上\n    let args = arguments[1]; // 获取参数数组\n    let result\n    // 处理传进来的第二个参数\n    if (args) {\n        // 是否传递第二个参数\n        if (!Array.isArray(args) && !isArrayLike(args)) {\n            throw new TypeError('myApply 第二个参数不为数组并且不为类数组对象抛出错误');\n        } else {\n            args = Array.from(args) // 转为数组\n            result = context[specialPrototype](...args); // 执行函数并展开数组，传递函数参数\n        }\n    } else {\n        result = context[specialPrototype](); // 执行函数 \n    }\n    delete context[specialPrototype]; // 删除上下文对象的属性\n    return result; // 返回函数执行结果\n};\n复制代码\n")])])]),a("h4",{attrs:{id:"你能手写实现一个bind吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你能手写实现一个bind吗"}},[t._v("#")]),t._v(" 你能手写实现一个"),a("code",[t._v("bind")]),t._v("吗？")]),t._v(" "),a("p",[a("strong",[t._v("划重点")]),t._v("：")]),t._v(" "),a("p",[t._v("手写"),a("code",[t._v("bind")]),t._v("是大厂中的一个高频的面试题，如果面试的中高级前端，只是能说出它们的区别，用法并不能脱颖而出，理解要有足够的深度才能抱得offer归！")]),t._v(" "),a("p",[a("strong",[t._v("思路")])]),t._v(" "),a("ol",[a("li",[t._v("拷贝源函数:\n"),a("ul",[a("li",[t._v("通过变量储存源函数")]),t._v(" "),a("li",[t._v("使用"),a("code",[t._v("Object.create")]),t._v("复制源函数的prototype给fToBind")])])]),t._v(" "),a("li",[t._v("返回拷贝的函数")]),t._v(" "),a("li",[t._v("调用拷贝的函数：\n"),a("ul",[a("li",[t._v("new调用判断：通过"),a("code",[t._v("instanceof")]),t._v("判断函数是否通过"),a("code",[t._v("new")]),t._v("调用，来决定绑定的"),a("code",[t._v("context")])]),t._v(" "),a("li",[t._v("绑定this+传递参数")]),t._v(" "),a("li",[t._v("返回源函数的执行结果")])])])])])}),[],!1,null,null,null);e.default=l.exports}}]);